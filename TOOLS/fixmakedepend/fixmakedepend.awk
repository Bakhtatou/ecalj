BEGIN{
 thisprogram="makedepend.awk"
 today=strftime("%F %H:%M:%S");
 g_n_dependlist=0;
}
/^#/{
  next;
}
/: *=/{
 next;
}
/:/{
#  print; 
  startdepend=1;
  add_dependlist($0);
  next;
}
/^\t/{
#  if (startdepend) {
#  print "<",$0,">";
#  }
  add_command($0);
  startdepend++;
  next;
}
{
 startdepend=0;
}

END{
  prt_makedepend();
}

func prt_makedepend( i,j)
{
   print "#prt_makedepend, generated by", thisprogram,",", today;
   for (i=1;i<=g_n_targetlist;i++) {
     if ( targetsource[i,0]==0 && commandlist[i,0]==0 ) { 
      print "#comment: drop dependency for ",targetlist[i], ", because it is cyclic" ;
      print ""
      continue;
      }
     printf("%s  :  ",targetlist[i]);
     for (j=1;j<= targetsource[i,0]; j++) {
        printf("%s  ",targetsource[i,j]);
     }
     printf("\n");
     for (j=1;j<= commandlist[i,0];j++) {
        print commandlist[i,j];
     }
     printf("\n");
   }
}

func add_command(line, itarget,n)
{
  itarget=g_itarget
  if (startdepend==1) {
     commandlist[itarget,0]=0;
  }
  commandlist[itarget,0]++;
  n=commandlist[itarget,0];
  commandlist[itarget,n]=line;
}

func add_dependlist(line, n,itarget)
{
   sub(":"," ",line);
   n=split(line,a);
   itarget=find_target(a[1]); 
   g_itarget=itarget

   for (i=2;i<=n;i++)  {
     if (a[1] != a[i] ) {
   add_targetsource(itarget,a[i]);
     }
   }

}

func find_target(targetname,   i)
{
  for (i=1;i<=g_n_targetlist;i++) {
     if ( targetname==targetlist[i]) {
        return i;
     }
  }
  g_n_targetlist++;
  i=g_n_targetlist;
  targetlist[i]=targetname;
  return i;
}

func add_targetsource(itarget,name,  i)
{
  for (i=1;i<= targetsource[itarget,0];i++) {
     if ( name==targetsource[itarget,i] ) {
         return;
     }
  }
  targetsource[itarget,0]++;
  i=targetsource[itarget,0];
  targetsource[itarget,i]=name;
}


