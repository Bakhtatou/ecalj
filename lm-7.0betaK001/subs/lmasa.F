      subroutine lmasa(prgnam,sbz,sctrl,sham,spot,slat,smix,
     .  sspec,ssite,sstr,sarray,sstrn)
C- ASA self-consistency loop
C ----------------------------------------------------------------------
Ci Inputs
Ci   prgnam:nam of main program
Ci   sbz   :struct for the Brillouin Zone; see routine ubz
Ci     Elts read: nkp
Ci     Stored:    *
Ci     Passed to: asars getzv bndasa asasx
Ci
Ci   sctrl :struct for program flow parameters; see routine uctrl
Ci     Elts read: nbas nclass nl nspec nspin loptc lasa lsx lncol lpgf
Ci                sdmod sdprm maxit zbak lcgf lscr lrs,7 lves,18+16 tol
Ci                quit nvario
Ci     Stored:    lscr lasa
Ci     Passed to: lgors supot asars lsets subasi getzv asamad asvsph
Ci                nwit suham bndasa asasx shoctl asalsq ioqpp
Ci
Ci   sham  :struct for parameters defining hamiltonian; see routine uham
Ci     Elts read: oeula neula ehk thrpv seref amgm
Ci     Stored:    *
Ci     Passed to: subasi asvsph suham bndasa asasx asalsq
Ci
Ci   spot  :struct for information about the potential; see routine upot
Ci     Elts read: opp osop ogrrme opnu oqnu oqc oqt orhrmx oves ovrmax
Ci                opmpol oqpp ovintr orhos oaamom
Ci     Stored:    ovdif
Ci     Passed to: supot asars asamad asvsph suham bndasa asasx shoctl
Ci                asalsq ioqpp
Ci
Ci   slat  :struct for lattice information; see routine ulat
Ci     Elts read: avw
Ci     Stored:    *
Ci     Passed to: supot asars asamad asvsph suham bndasa asasx asalsq
Ci
Ci   smix  :struct for charge mixing parameters; see routine umix
Ci     Elts read: b bv w wc nsave mmix
Ci     Stored:    *
Ci     Passed to: *
Ci
Ci   sspec :struct for species-specific information; see routine uspec
Ci     Elts read: idmod z lmxa grp2
Ci     Stored:    *
Ci     Passed to: asars subasi asamad asvsph suham bndasa asasx shoctl
Ci                asalsq pvpqm1
Ci
Ci   ssite :struct for site-specific information; see routine usite
Ci     Elts read: *
Ci     Stored:    *
Ci     Passed to: asars suham bndasa asasx magtrq
Ci
Ci   sstr  :struct for parameters for screened strux; see routine ustr
Ci     Elts read: n sxopt mix amix
Ci     Stored:    *
Ci     Passed to: *
Ci
Ci   sarray:structure containing offsets to various arrays
Ci     Elts read: ohave oics oclabl onrcp oipc npadl npadr nclasp ormax
Ci                ogroup
Ci     Stored:    *
Ci     Passed to: asamad asvsph suham bndasa asasx shoctl asalsq
Ci
Ci   sstrn :struct for global strings
Ci     Elts read: sxopt mix amix
Ci     Stored:    *
Ci     Passed to: suham bndasa asasx
Co Outputs
Cr Remarks
Cr  This is the entry point for the self-consistent ASA band program
Cr
Cr  lmasa contains two main blocks.  One part generates the potential
Cr  from input moments and generates potential parameters as output.
Cr  The ASA interatomic electrostatic potential is generated by asamad,
Cr  while asvsph handles the sphere part.
Cr
Cr  The other block generates eigenvalues, Green's functions, and
Cr  the like from input potential parameters.  One output of
Cr  these blocks are moments, which complete the cycle.  The
Cr  routines generating outputs of the hamiltonian are:
Cr     bndasa:  Eigenvectors and output moms from the ASA hamiltonian.
Cr     gfasa:   crystal Green's function
Cr     pgfasa:  layer Green's function
Cr  Also:
Cr     asasx:   Rucker's screened exchange potential is implemented to
Cr              date and requires output of bndasa.
Cr     magtrq:  generates magnetic forces, rotates magnetic spins
Cr              based on output from noncollinear bndasa, gfasa.
Cr
Cr  The first band iteration is nit=1.  It is possible to do
Cr  a band calculation without moments as input, provided pot. pars.
Cr  are supplied.
Cr
Cl Local variables
Cl   ehterm: parameters needed to make Harris energy
Cl            (1) etot for VH(rmt)=0 (2) sumeV(VH=0)
Cl            (3) sum Q_R V_R        (4) emad
Cl            (5) int input applied field * input density
Cl            (6) int input applied field * output density
Cl          NOTE: this array is archaic.  Will be superseded
Cl                by sham->eterms when the latter is stabilized.
Cl   latok :1s digit
Cl           0 input potential not read or created
Cl           1 input potential is available
Cl         10s digit
Cl          0 parameters to gen. total energy available
Cl          1 parameters to gen. total energy not available
Cl   makepp: F do not update potential or make ppars
Cl           T update potential and make ppars from moments
Cl   etrmss: backup double-counting terms sham->eterms, used
Cl         : when potential, P,Q are kept frozen (see makepp=F)
Cl         : in e.g. frozen-potential SD
Cl   nwmoms: T output moments have been generated
Cl   sdmod : see doc/nc.txt.
Cl           1s digit:
Cl            0 Output Euler angles from density matrix
Cl            1 relax along force
Cl            2 dynamics
Cl           10s digit (for spin statics only)
Cl            0 mix Euler angles with charge moments P,Q
Cl            1 independently mix Euler angles
Cl           1000s digit
Cl            causes lm to prevent updating of atomic P and Q,
Cl            and the potential parameters.
Cl  vconst  :(gf,pgf) Constant estat potential shifts, used where
Cl          : the Fermi level is specified and the potential
Cl          : adjusts to it.
Cl          : vconst(1) = potential shift
Cl          : vconst(2) = potential shift of L end region (PGF)
Cl          : vconst(3) = potential shift of R end region (PGF)
Cl   vrl    : Difference in estat potential in the left- and right- electrodes
Cl          : Consider the equilibrium case first.
Cl          : Right now, the code solves the electrostatics by Ewald
Cl          : summation using periodic boundary conditions.  To make the
Cl          : potential continuous everywhere, an additional linear
Cl          : solution V(z)=[vconst(3)-vconst(2)]*z/Lz is required.  This
Cl          : drop in potential will be distributed properly by the
Cl          : self-consistency condition, satisfying boundary conditons
Cl          : that the potential difference across the leads is
Cl          : [vconst(3)-vconst(2)].  Thus, the potential is continuous.
Cl
Cl          : In the nonequilibrium case, the bias across the device 
Cl          : creates a difference in Fermi level across the left and right
Cl          : leads.  Combining the two effects,
Cl          : vrl = [vconst(3)-vconst(2)] + ef(R)-efermi, where 
Cl          : ef(R) and efermi are fermi energies of right and left leads.
Cu Updates
Cu   08 Nov 07 (J. Xu) New LDA+U ASA hamiltonian
Cu   19 Jul 07 (S.Faleev) corrected electrostatics in pgf case, when
Cu             left- and right- leads are different
Cu   17 Mar 05 (T.Sandu) GF can generate SX sigma
Cu   10 Jul 04 (S.Faleev) Changes to handle non-equilibrium mode
Cu   21 Apr 04 Additions for an m-dependent spin-density matrix
Cu   23 Sep 03 SX patterned after GW.  sigm(irr k) generated
Cu             and stored in file sigm.  sigm(rs) obtained
Cu             by call to rdsigh.
Cu   04 Sep 03 Expand dxmprm so wa may have independent value
Cu   30 Apr 03 Added MPI read/write for rsta.
Cu   20 Mar 03 Added etol as a tolerance for self-consistency
Cu   10 Mar 03 First cut at making proper Kohn-Sham energy.
Cu   17 Feb 03 Added double-counting terms for applied field
Cu   27 Jan 03 Changes to noncollinear code
Cu   24 May 02 small changes to better decouple sx and scr modes
Cu   01 Mar 02 revisions to accomodate changes to PGF codes
Cu   19 Feb 02 revisions to accomodate changes to GF codes
Cu   07 Jun 01 use call to nwit to check convergence
Cu   17 May 01 First attempt for I/O from rst file
Cu   17 Sep 99 start streamlining with sham,spot,fewer passed arguments
Cu   28 Apr 98 add code for radial matrix elements of grad
C ----------------------------------------------------------------------
C     implicit none
C ... Passed parameters:
      character*(*) sstrn, prgnam*8
      double precision sarray(1),sbz(1),sctrl(1),slat(1),smix(1),
     .  sspec(1),ssite(1),sham(1),spot(1),sstr(1)
C ... Heap
      integer w(1)
      common /w/ w
C ... Local variables
      character*120 outs, sxopts*120
C     character ch*1
      logical bittst,cmdopt,lgors,T,F,makepp,nwmoms,lmfrce,aintra,
     .  sw,lfree
      parameter (T=.true., F=.false.)
      integer oeband,oqold,oeula,oeulo,ofrc,ogroup,oics,oidmod,oinitc,
     .  oipc,olmx,onrcp,opnu,opold,opnus,opp,oqc,oqnu,oqnus,oqt,orhos,
     .  orhrmx,ormax,osop,ogrrme,opmpol,ovdif,oves,ovintr,ovold,ovrmax,
     .  owk,owk2,oz,oaamom,oclabl,odq,oxold,oxnew,omxcst
      integer a2vec,bitand,fopn,fopna,fxst,getdig,i,i1,i2,ifi,igets,
     .  imake,stdo,nglob,lham,lves,iprint,iprt,isw,iv(10),lgunit,lasa,
     .  lpgf,lcgf,lncol,lsx,lnsph,loptc,nband,nbas,nclasp,nclspp,nclass,
     .  nevmx,nl,nlspcp,nsp,nspec,sdmod,iscr,neul,nrhos,latok,iscsav
      integer mpipid,procid,master
      double precision ehterm(6),thrpv,amgm,sumev,sevat,etol,ehf,ehk,
     .  ehk0,seref,amag(3),efermi(2),emad,trumad,vmtz(2),zval,zbak(2),
     .  avw,dgets,xv(10),zdel(2),pmin(10),etot(2),etrmss(20),vconst(3),
     .  vcnsts(3)
      equivalence (etot(1),ehf),(etot(2),ehk)
C ... Parameters for iterations
      integer lsc,irs(5),nit,maxit
C ... Parameters for nonspherical density
      integer nqpp,oqpp,oqppo
C ... Parameters for spin dynamics
      double precision sdprm(6)
C ... Parameters for mixing.  Default parameters dmxprm:
C 1(I) mixing scheme; 2 beta; 3 wc; 4,5 wgt; 6(I)nsave 7(I) mmix;
C 8(I) nkill; 9 betv; 10 rmscst.  11-20 are outputs:
C 11 rmsdel 12 rms2 13 nmix 14 actual broy 15 actual beta 16-24 tj
C 25 1 if wt ne 0, 10 if wa ne 0, 11 if all nonzero
C 27..29: hold parms for static parms block regular mixing
C 30..32: hold parms for static parms block Euler angle mixing
C 33 : Lindhard screening parameter
C 34 : wa
      double precision dmxprm(34),dmxeu(34),rmsdel,rms2,betsv,rmscst,
     .  betv,qtol
      equivalence (dmxprm(9),betv),(dmxprm(10),rmscst),
     .  (dmxprm(11),rmsdel),(dmxprm(12),rms2),(dmxprm(15),betsv)
C ... Parameters for GF
#if GF
      logical a2bin
      integer moddos,nzp,npl
      integer ozp,owz,olgii,oogll,opgfsl,opgplp,ovshft,ovshfs
      double precision semsh(10)
C ... Parameters for non-equilibrium mode
      integer nzne,j
      logical lnoneq
#endif
      double precision vne,vrl
      integer npadl,npadr,nbasp
      integer ogrp2
C     for SX potential
      integer lrsig,lrsigl,ldham(16),lwsig
      double precision rsrnge
C..   new param for SX
      logical sxad
C.... Local parameters for LDA+U
      integer olldau,ovorb,odmatu,odmato,nlibu
      integer lmaxu,ng,ngi,oistab,og
      double precision umix,tolu

C ---------------------------- Setup ---------------------
C     call tcn('lmasa')
C ... Default values for mixing
      call dpzero(ehterm,6)
      call dpzero(dmxprm,34)
      call dpzero(vconst,3)
      call upack('mix b bv w wc',smix,dmxprm(2),dmxprm(9),dmxprm(4),
     .  dmxprm(3),0)
      dmxprm(6) = igets('mix nsave',smix)
      dmxprm(7) = igets('mix mmix',smix)
      call upack('ctrl nbas nclass nl nspec nspin',sctrl,nbas,nclass,nl,
     .  nspec,nsp)
      call upack('ctrl loptc lasa lsx lncol lham',sctrl,loptc,lasa,lsx,
     .  lncol,lham)
      lpgf = igets('ctrl lpgf',sctrl)
      call upack('ham oeula neula',sham,oeula,neul,0,0,0)
      call upack('pot opp osop ogrrme',spot,opp,osop,ogrrme,0,0)
      call upack('ctrl sdmod sdprm maxit zbak',sctrl,sdmod,sdprm,
     .  maxit,zbak,0)
      lcgf = igets('ctrl lcgf',sctrl)
      iscr = mod(igets('ctrl lscr',sctrl),10)
      lrsig = igets('ham lsig',sham)
      call upack('array ohave oics oclabl onrcp oipc',sarray,oinitc,
     .  oics,oclabl,onrcp,oipc)
      call upack('array npadl npadr nclasp ormax ogroup',sarray,npadl,
     .  npadr,nclasp,ormax,ogroup)
      call upack('pot opnu oqnu oqc oqt',spot,opnu,oqnu,oqc,oqt,0)
      call upack('pot orhrmx oves ovrmax opmpol oqpp',spot,orhrmx,oves,
     .  ovrmax,opmpol,oqpp)
      call upack('pot ovintr orhos oaamom nrhos',spot,
     .  ovintr,orhos,oaamom,nrhos,0)
      call sp2cls('spec idmod',sspec,w(oics),nl,1,nclasp,oidmod)
      call upack1('lat avw',slat,avw)
      lnsph = isw(lgors('ctrl lasa,32',sctrl))
      lfree = lgors('ctrl lasa,8',sctrl)
      call supot(1,sctrl,slat,spot)
      vne = 0
      vrl = 0
      stdo = lgunit(1)
      procid = mpipid(1)
      master = 0

C ... Input from restart file
      if (cmdopt('--rs=',5,0,outs)) then
      irs(1) = igets('ctrl lrs,7',sctrl)
      if (irs(1) .gt. 0) then
        if (procid .eq. master) ifi = fopna('rsta',-1,0)
        call mpibc1(ifi,1,2,.false.,'lmasa','ifi')
        call asars(0,sctrl,ssite,sspec,slat,spot,sbz,w(opnu),w(oqnu),
     .    .false.,ifi)
        call clsprp(1,sctrl,sarray,sham,spot,sspec,slat,sbz,sstr,sstrn)
        if (procid .eq. master) call fclr('rsta',ifi)
C       call shoctl(sctrl,sspec,spot,sarray,0,stdo)
C       call rx('done')
      endif
      endif

#if PGF
C     for now
      iv(3) = 0
      iv(4) = 0
      if (cmdopt('-nofg=',6,0,outs)) then
        i = 6
        i = a2vec(outs,len(outs),i,2,', ',2,2,2,iv,iv(3))
      endif
      call pack2('array nofgl nofgr',sarray,iv(3),iv(4))

      if (lpgf .eq. 2) iscr = 0
#endif

      nbasp  = nbas + npadl + npadr
      nclspp = 2*nclasp-nclass
      nlspcp = nl*nsp*max(nclspp,nspec)
      nqpp   = (nl**2*(nl**2+1))/2
      lmfrce = bittst(lncol,16) .and. bittst(lncol,1)
      if (cmdopt('-noves',6,0,outs)) call lsets('ctrl lves',sctrl,T,1)
      lves   = 2*igets('ctrl lves,1',sctrl)
      emad = 0
      trumad = 0
      seref = 0
      latok = 0
      call defrr(ovdif,-nclspp)
      call pack1('pot ovdif',spot,ovdif)
C ... class-based arrays
      call sp2cls('spec z',sspec,w(oics),1,1,nclasp,oz)
      call sp2cls('spec lmxa',sspec,w(oics),1,1,nclasp,olmx)
C     call sp2cls('spec idxdn',sspec,w(oics),nl,1,nclasp,oidxdn)
      call sp2cls('spec grp2',sspec,w(oics),1,1,nclasp,ogrp2)
C     call redfi(ogrp2,nclasp)
C ... Other initialization
      call subasi(sctrl,sspec,sham)
      nband = nbas*nglob('mxorb')
      call defdr(oeband,nband*nsp*igets('bz nkp',sbz))

C ... Setup for charge mixing
      call parms0(dmxprm(30),dmxprm(31),dmxprm(32),1)
      if (lmfrce) then
        call dpzero(dmxeu,34)
        call dcopy(25,dmxprm,1,dmxeu,1)
      endif
      if (cmdopt('--mix=',6,0,outs)) then
        i = 6
        iv(4) = 1
        i = a2vec(outs,len(outs),i,2,', ',2,2,2,iv,iv(3))
        iv(4) = max(iv(4),1)
        call parmx0(iv(3),iv(4),0d0)
      endif

C ... Green's function specific setup
#if GF
      call upack1('bz semsh',sbz,semsh)
      nzp = nint(semsh(1))
C ... setup for non-equilibrium mode
      call setne(sbz,sctrl,nzne,vne,lnoneq)
      if (lnoneq .and. (iscr .ne. 0 .or. lves .ne. 0) )
     . call rx ('lmasa not ready for iscr!=0 or lves!=0 in non-eq mode')

      i = 4
      if (cmdopt('-ef=',i,0,outs)) then
        if (.not. a2bin(outs,efermi,4,0,' ',i,-1)) call
     .    rxs2('LMASA: failed to parse "',outs(1:30),'%a"')
        call awrit2('%N Override file fermi level, use ef= %,6d, '//
     .    'delef= %,6d%N',' ',80,stdo,efermi,efermi(1)-semsh(4))
        i = mod(nint(semsh(2)),100)
        if (i .ne. 2) semsh(4) = efermi(1)
        call pack1('bz semsh',sbz,semsh)
      endif
      efermi(1) = semsh(4)

      call defdc(ozp,nzp+nzne)
      call defdc(owz,nzp+nzne)
      call emesh(semsh,w(ozp),w(owz))
      call upack('array opgfsl opgplp',sarray,opgfsl,opgplp,0,0,0)
      call upack1('ctrl npl',sctrl,npl)
      call upack1('pot ovshf',spot,ovshft)

      i = 1+4
#if PGF
      i= 2+4
#endif
      ifi = fopn('VSHFT')
      call iovshf(nbas,i,'read file vshft: ef=%d  vconst=%d',
     .  efermi,xv,vconst,w(ovshft),ifi)
      call pack1('pot vconst',spot,vconst)
      call fclr('VSHFT',-1)
      call defdr(ovshfs, 8+nbasp)
#if PGF
      vrl = vne + vconst(3)-vconst(2)
#endif
#else
#endif

C ------------------- Generate ASA potential ------------------
      makepp = mod(lasa,4) .ne. 0 .and. getdig(sdmod,3,10) .eq. 0
      nwmoms = .false.
      nit = 0
   10 continue

C --- Madelung energy, potential, number of valence electrons ---
      call pshpr(0)
      call defdr(odq,nclasp)
      call getq(nsp,nl,w(olmx),nclasp,w(oz),w(opnu),w(oqnu),w(oics),
     .  sspec,w(oqc),w(oqt),w(odq))
      call togprt
      call getzv(nclasp,w(onrcp),w(oz),w(oqc),sbz,sctrl,zval)
      call togprt
      call rlse(odq)
C ... undo shift that would be added to pp's when they are made
C     in case they are not made
      call shftpp(nclasp,nl*nsp,w(opp),w(oves),w(oves),T,F)
      call asamad(sctrl,spot,sarray,slat,sspec,lves+100,
     .  w(opnu),w(oqnu),vrl,w(oves),emad,trumad,vmtz)
C ... add shift for v as have now
      call shftpp(nclasp,nl*nsp,w(opp),w(oves),w(oves),F,T)
      call poppr

C --- Sphere program.  Make potential parameters ---
      imake = 0
      if (makepp) imake = 3
      if (bitand(lasa,3) .ge. 2) imake = 2
      if (imake .eq. 3 .and. lfree) imake = 1
      if (bitand(lasa,3) .eq. 3)
     .  call rx('lmasa: not ready for BEGMOM=3')
C     Temporarily set lscr when making vintra only selected iterations
      iscsav = igets('ctrl lscr',sctrl)
      if (mod(iscsav,100) .ge. 20) then
        if (mod(nit,mod(iscsav,100)/10) .ne. 0)
     .    call pack1('ctrl lscr',sctrl,0)
      endif
      call asvsph(sctrl,slat,sarray,sspec,sham,spot,vrl,imake,
     .  ehterm,latok)

      call upack1('ham eterms',sham,etrmss)
      amgm = dgets('ham eterms:15',sham)
      sevat = dgets('ham eterms:16',sham)
C     Reset lscr
      call pack1('ctrl lscr',sctrl,iscsav)

C ... Update second-padded pnu,qnu, in case they changed
#if PGF
      call clsprp(1,sctrl,sarray,sham,spot,sspec,slat,sbz,sstr,sstrn)
#endif

C ... Save convergence data in save file
      if (nit .gt. 0 .and. procid .eq. master) then
        call poseof(fopn('SV'))
        do  57  i = 1, 3
          if (i .eq. 1 .and. iprint() .lt. 10) goto 57
          ifi = lgunit(i)
          if (i .eq. 3) ifi = fopn('SV')
          call iosv(-ifi,nit,dmxprm,ehk,amgm,.true.)
   57   continue
        call fclose(fopn('SV'))
      endif

C --- Re-entry point for non-self-consistent calculations ---
   58 continue

C ... Output to restart file (eventually only for nit>0)
      if (cmdopt('--rs=',5,0,outs)) then
        irs(2) = igets('ctrl lrs,8+16',sctrl)/8
        if (irs(2) .gt. 0) then
          if (procid .eq. master) ifi = fopna('rsta',-1,0)
          call mpibc1(ifi,1,2,.false.,'lmasa','ifi')
          call asars(0,sctrl,ssite,sspec,slat,spot,sbz,
     .      w(opnu),w(oqnu),.false.,-ifi)
          if (procid .eq. master) call fclr('rsta',ifi)
        endif
      endif

C --- Print out summary of this iteration, check for convergence ---
      lsc = 3
      if (nit .gt. 0) then
        xv(3) = ehf
        xv(4) = ehk
        qtol = dgets('ctrl tol',sctrl)
        etol = dgets('ctrl tol:3',sctrl)
        xv(1) = rmsdel
C       Independent mixing of Euler angles: combine rms dq, deuler
        if (getdig(sdmod,1,10).eq.1) xv(1)=sqrt(rmsdel**2+dmxprm(32)**2)
        if (procid .eq. master) then
          call nwit(igets('ctrl nvario',sctrl),nit,maxit,.false.,1,etol,
     .      qtol,xv,'cxhi',amgm,xv(3),lsc)
        endif
        call mpibc1(lsc,1,2,.false.,'lmasa','lsc')
      elseif (iprint() .ge. 10 .and. makepp) then
C       Extract calculated energy parameters
        call upack('ham ehk thrpv seref',sham,ehk0,thrpv,seref,0,0)
        do  55  i = 1, 2
          call awrit6('%x '//prgnam//'%a: it %i of %i  '//
     .      'ehk0=%1,6d  pv=%1;4d  mmom=%1;4d'//'  seref=%1;6d',outs,
     .      80,lgunit(i),nit,maxit,ehk0,thrpv/3,amgm,seref)
   55   continue
      endif
      if (iprint() .gt. 30) call cpudel(stdo,'...   Time this iter:',xv)

C ... Invoke shell command if supplied
      outs = ' '
      if (nit .gt. 0 .and. cmdopt('--sh=',5,0,outs)) then
        call awrit0(' LM: invoke sh="'//outs(6:len(outs))//'%a"',
     .    ' ',len(outs),stdo)
        call fsystm(outs(6:len(outs)),i)
        call awrit1(' LM: shell returned value %i',' ',80,stdo,i)
      endif

C ... When quit is specified or insufficient information to continue
      if (igets('ctrl quit',sctrl).eq.2 .or. getdig(latok,0,10) .eq. 0
     .    .or. bittst(lasa,8)) then
        call info0(0,0,0,' '//prgnam//
     .    '%a:  Q=ATOM encountered or missing input')
        goto 99
      endif
C ... Spin statics or dynamics: charge self-consistency not a criterion
      if (lsc .eq. 0 .and. lmfrce .and. getdig(sdmod,0,10).gt.1) lsc=3
C ... Interactive query for number of iterations
      call ftflsh(stdo)
      if (lsc .eq. 0) then
        if (procid .eq. master) write(stdo,302) rms2
  302   format(/' Jolly good show !  You converged to rms DQ=',f10.6)
        goto 99
      endif
      call query('max it',2,maxit)
      if (nit .ge. maxit) goto 99
      nit = nit+1
C ... If subsequent iterations have moments in hand
      makepp = makepp .or. nwmoms
      makepp = makepp .and. getdig(sdmod,3,10) .eq. 0

C ------------------------- Band pass --------------------------
C ... Keep a copy of input P,Q and related parameters
      call defdr(opold,nlspcp)
      call defdr(oqold,3*nlspcp)
      call defdr(ovold,nclspp)
      call defdr(oeulo,3*neul*nbasp)
      call dcopy(nlspcp,w(opnu),1,w(opold),1)
      call dcopy(3*nlspcp,w(oqnu),1,w(oqold),1)
      call dcopy(nclspp,w(oves),1,w(ovold),1)
      if (lnsph.ne.0) then
        call defcc(oqppo,nqpp*4*nsp*nbas)
        call dcopy(2*nqpp*4*nsp*nbas,w(oqpp),1,w(oqppo),1)
      endif

      call suham(sctrl,slat,sspec,ssite,sarray,sham,spot,sstrn)

C ... Quit if --quit=ham given
      if (igets('ctrl quit',sctrl) .eq. 8) then
        call rx0('quit = ham')
      endif

C ... Read and store self-energy addition to LDA potential
      call upack1('ham ldham',sham,ldham)
      lrsigl = lrsig
      if (lrsigl .ne. 0 .and. fxst('sigm') .ne. 1) then
        call info0(1,1,0,' lmasa (warning): '//
     .    'no sigm file found ... LDA calculation only')
        call pack1('ham lsig',sham,0)
        lrsigl = 0
      endif
      sxad = F
      if (mod(lrsigl,10) .ne. 0) then
C       Real-space range
        rsrnge = dgets('ham rsrnge',sham)
        ifi = fopna('sigm',-1,4)
        call rdsigm(1000+lrsigl,nbas,nsp,ldham(1),slat,sham,
     .    sbz,ifi,rsrnge,lwsig)
        call fclose(ifi)
        sxad = T
      endif

C ... LDA+U initialization
      call defi(olldau, -nbasp)
      call defrr(ovorb,1)
      call defcc(odmatu,1)
      call defcc(odmato,1)
      
C     Check for LDA+U ... return nlibu > 0 if any U blocks.
      call suldau(nbasp,sspec,ssite,nlibu,lmaxu,w(olldau))
      call pack5('ham nlibu lmaxu',sham,nlibu,lmaxu,0,0,0)
        
C ... Read LDA+U Hamiltonian
      if (nlibu .gt. 0) then
        call rlse(ovorb)
        i = nsp*nlibu*(lmaxu*2+1)**2
        call defcc(ovorb,-i)
        call defcc(odmatu,-i)
        call defcc(odmato,-i)
C       need group info to symmetrize site density matrix
        call upack('lat nsgrp oistab osymgr',slat,ng,oistab,og,0,0)
C       layer GF code doesn't have istab for padding layers.
        ngi = ng
        if (lpgf .ne. 0) then
          ngi = 0
        endif
        call upack('mix umix tolu',smix,umix,tolu,0,0,0)
C       initialize density matrix for LDA+U

        i = 0
        if (bittst(lham,256)) i = 1
        call sudmtu(nbasp,nsp,nlibu,lmaxu,ssite,sspec,i,w(olldau),
     .    ngi,w(og),w(oistab),w(odmatu),w(ovorb))
          
C       Hang on to previous site density matrix for this iteration
        i = nsp*nlibu*(lmaxu*2+1)**2
        call dcopy(2*i,w(odmatu),1,w(odmato),1)
        call dpzero(w(odmatu),2*i)

      endif

C --- Green's function approaches ---
#if GF
      if (lpgf .ne. 0) then
#if PGF
        call defi(oogll,npl+4)
        call defi(olgii,npl+4)
        call iinit(w(olgii),npl+4)

CC       Printout vshft
C        call iozshf(nbasp,1,w(ovshft),w(oipc),w(ogrp2),-stdo)
CC       Replicate vshft->vshfs; distribute averages for pgfasa
CC       Now done in pgfasa
CC       call vshfav(11,npl,w(opgplp),w(ovshfs),w(ovshft))

        call pgfasa(sctrl,slat,sarray,sspec,ssite,sbz,sstr,sham,spot,
     .    sstrn,w(olldau),w(ovorb),w(odmatu),
     .    vconst,w(ovshft),w(ozp),w(owz),w(opgfsl),w(opgplp),
     .    efermi,moddos,sumev,w(oqnu),w(orhos),amag,w(oaamom),w(olgii),
     .    w(oogll))
        if (mod(mod(moddos,10),2) .ne. 1) goto 99
        nevmx = 1
C       call shoctl(sctrl,sspec,spot,sarray,0,stdo)

C       Add vshft(ib) to vdif to make etot when Ves ne Ves[n]
        if (lves .eq. 2)
     .    call vsh2es(1,nbasp,w(oipc),w(onrcp),w(ovshft),w(ovdif))
C       Update vshft file
        if (lpgf .le. 2) then
          ifi = fopn('VSHFT')
          call iovshf(nbas,6,' ',efermi,efermi,vconst,w(ovshft),-ifi)
          call fclr('VSHFT',-1)
        endif

#endif
#if CGF
      elseif (lcgf .ne. 0) then

C       Temporarily set lscr when making psta only selected iterations
        iscsav = igets('ctrl lscr',sctrl)
        if (mod(iscsav,1000) .ge. 200) then
          if (mod(nit,mod(iscsav,1000)/100) .ne. 0)
     .      call pack1('ctrl lscr',sctrl,0)
        endif
        call dpcopy(vconst,vcnsts,1,3,1d0)
        call gfasa(sctrl,slat,sarray,sspec,ssite,sbz,sham,spot,sstrn,
     .    w(olldau),w(ovorb),w(odmatu),
     .    vconst,w(ovshft),w(ozp),w(owz),w(opgplp),efermi,moddos,sumev,
     .    ehterm,w(oqnu),w(orhos),amag,w(oaamom),sxad)
C       Reset lscr
        call pack1('ctrl lscr',sctrl,iscsav)

        if (mod(mod(moddos,10),2) .ne. 1) goto 99
        nevmx = 1
C       call shoctl(sctrl,sspec,spot,sarray,0,stdo)

C       Add vshft(ib) to vdif to make etot when Ves ne Ves[n]
        if (lves .eq. 2)
     .    call vsh2es(1,nbasp,w(oipc),w(onrcp),w(ovshft),w(ovdif))

C       Update vshft file
        ifi = fopn('VSHFT')
        call iovshf(nbas,5,' ',efermi,efermi,vconst,w(ovshft),-ifi)
        call fclr('VSHFT',-1)


C  ... Check convergence of dmatu and update it and vorb if necessary
        if (nlibu .gt. 0 .and. maxit .gt. 0) then        
        i = 0
        if (bittst(lham,256)) i = 1
          call chkdmu(nbas,nsp,nlibu,lmaxu,ssite,sspec,sham,i,w(odmatu),
     .      w(odmato),w(ovorb),tolu,umix,w(olldau),ng,w(og),w(oistab))
        endif

#endif
      else
C        if (mordrn .eq. EMCLUS) then
C          call rx('emc not ready')
C          call emc2C(s_ordn,nl,nlo,nsp,nbas,w(olmx),nclass,w(oipc),
C     .      w(oeula),switch,w(opp),vmtz,elin,wsr,
C     .      efmax,nevmx,z,w(oqc),w(oeband),nband,
C     .      norder,width,range,npts,drange,
C     .      avw,zval,plat,w(obas),w(ogroup),efermi,sumev,w(orhos))
C        endif
        call rx('no technique specified to generate density')
      endif

#else
C --- Energy bands by direct diagonalization ---
C     Suppress ccor if generating evecs for response function
      if (mod(lsx,2) .eq. 1 .or. mod(iscr,2) .eq. 1)
     .  call pack1('ctrl lasa',sctrl,lasa-bitand(lasa,4))
      call bndasa(sctrl,slat,sspec,ssite,sarray,sbz,sham,spot,sstrn,
     .  w(ovorb),w(odmatu),
     .  efermi,w(oeband),nband,nevmx,w(oqnu),sumev,w(orhos),amag,
     .  w(oaamom))

C ... Check convergence of dmatu and update it and vorb if necessary
      if (nlibu .gt. 0 .and. maxit .gt. 0 .and. nevmx .gt. 0) then        
        i = 0
        if (bittst(lham,256)) i = 1
        call chkdmu(nbas,nsp,nlibu,lmaxu,ssite,sspec,sham,i,w(odmatu),
     .    w(odmato),w(ovorb),tolu,umix,w(olldau),ng,w(og),w(oistab))
      endif

      call pack1('ctrl lasa',sctrl,lasa)

C --- Rucker's screened exchange ---
#if SX
      if (mod(lsx,2) .eq. 1 .or. mod(iscr,2) .eq. 1) then
        aintra = T
        zdel(1) = 0
        zdel(2) = 0
        call upacks('strn sxopt',i1,i2)
        sxopts = ' '
        if (i2 .ge. i1) sxopts = sstrn(i1:i2)
        if (mod(lsx,2) .eq. 0) sxopts = 'pstat'
        if (cmdopt('-novintr',4,0,outs))
     .    call dpzero(w(ovintr),nclasp*nl*nl*nsp*nsp)
        call asasx(sctrl,sspec,ssite,sarray,slat,sham,spot,sbz,sstrn,
     .    sxopts,aintra,nl,nsp,efermi,w(oeband),nband,zdel,w(ovintr))
C        call rx0('finished calling asasx ('//sxopts//'%a)')
        goto 99
      endif
#endif
c###### (SX branch)

      if (nevmx.gt.0 .and. procid .eq. master) then
        call shoctl(sctrl,sspec,spot,sarray,0,fopn('LOG'))
      endif

#if STONER
      if (lgors('ctrl lstonr',sctrl)) then
        call defdr(onbar,mnpts)
        call defdr(oewk,mnpts)
        call defdr(omwk,mnpts)
        call defdr(oamom,-nbas)
        call defdr(oemag,-nbas)
        call rx('fix clabl for call to stoner')
        call stoner(nl,nbas,nclass,clabl,w(oipc),w(oidxdn),efermi,
     .    drange,iabs(npts),w(ozos),w(oindex),w(ostni),w(oammx),
     .    mnpts,switch(44),w(onbar),w(oewk),w(omwk),w(oamom),
     .    w(oemag))
      endif
#endif

#endif
c######  (hamiltonian or GF branches)

C --- Harris and HK energies if terms are available ---
C ... OLD STYLE
C      ehterm(5) = dgets('ham eterms:17',sham)
C      ehterm(6) = dgets('ham eterms:18',sham)
C      call cwrite(' *** OLD',0,7,0)
C      xv(1) = 0
C      if (getdig(latok,1,10) .eq. 0) then
C        ehf = 0
C      else
C        if (lves .eq. 2 .and. nevmx .gt. 0) call ehcor(nclasp,w(onrcp),
C     .    w(oclabl),w(ovdif),nl,nsp,w(oqold),w(oqnu),xv(1))
C        xv(2) = sumev-ehterm(2)-ehterm(3)-ehterm(5)
C        ehf = xv(2) + xv(1)*0 + ehterm(1) + ehterm(4)
C        do  34  i = 1, 2
C          if (xv(1) .eq. 0) call awrit3(' '//prgnam//
C     .      '%a: ehf=%1,7;7d  sumev=%1,7;7d  delsev=%1,7;7d',outs,80,
C     .      lgunit(i),ehf,sumev,xv(2))
C          if (xv(1) .ne. 0) call awrit4(' '//prgnam//
C     .      '%a: ehf=%1,7;7d  sumev=%1,7;7d  delsev=%1,7;7d  ehcor='//
C     .      '%d (not inc)',outs,80,lgunit(i),ehf,sumev,xv(2),xv(1))
C   34   continue
C      endif

C ... HF energy
      ehf = 0
      if (getdig(latok,1,10) .ne. 0) call asetot(1,sham,sumev,ehf)
C ... HK energy
      ehk = 0
      if (nevmx .gt. 0) then
        call pshpr(max(iprt(1)-100,0))
        call pshpr(max(iprt(1)-20,0))
        call asvsph(sctrl,slat,sarray,sspec,sham,spot,vrl,4,
     .    ehterm,latok)
        call poppr
        call poppr
        if (getdig(latok,1,10) .ne. 0) call asetot(2,sham,sumev,ehk)
      endif

      if (ehf .ne. 0) then
        do  i = 1, 2
          if (iprint() .ge. 10 .or. i .eq. 2) then
            call awrit6('%N '//prgnam//'%a: '//
     .        'ehf=%1,7;7d  %?#n#ehk=%1,7;7d  #%j#sumev=%1,7;7d'//
     .        '%?#n#  delsev=%1,7;7d',
     .        outs,80,lgunit(i),
     .        ehf,isw(ehk.ne.0),ehk,sumev,isw(sevat.ne.0),sumev-sevat)
          endif
        enddo
      endif

C --- Early program exit ---
      if (igets('ctrl quit',sctrl) .eq. 4 .or. nevmx .le. 0) then
        i = igets('ctrl nvario',sctrl)
        if (procid .eq. master) then
          call nwitsv(1+2,i,'h67',nsp,amgm,etot)
        endif

C   ... Invoke shell command if supplied
        outs = ' '
        if (nit .gt. 0 .and. cmdopt('--sh=',5,0,outs)) then
          call awrit0(' LM: invoke sh="'//outs(6:len(outs))//'%a"',
     .      ' ',len(outs),stdo)
          call fsystm(outs(6:len(outs)),i)
          call awrit1(' LM: shell returned value %i',' ',80,stdo,i)
        endif

        call rx0(prgnam//': quit after bands')
      endif

C --- Magnetic torque ---
#if NC
      if (lmfrce) then
        call dcopy(3*neul*nbasp,w(oeula),1,w(oeulo),1)
        call defrr(ofrc, 3*nbas+3)
        call magtrq(nbasp,nl,nclasp,w(oipc),sdmod,sdprm,ssite,sspec,
     .    w(oclabl),w(opp),w(orhos),nrhos,ehf,w(oeula),neul,w(ofrc),
     .    w(oaamom))
        if (mod(sdmod,10) .eq. 3) then
          call rx('lmasa not ready for sdmod=3')
CC     ... for now, copy eula to work array with one eula/atom
C          stop 'nl->neula'
C          call defrr(owk2, 2*nbas+3)
C          call dpscop(w(oeula),w(owk2),nbasp,nbasp*nl+1,nbas+1,1d0)
C          call dpscop(w(oeula),w(owk2),nbasp,1,1,1d0)
C          call defrr(owk, 3*nbas+3)
C          print *, 'put irmmd in bsi,bswk'
C          call u_bsi(s_sdyn,i,j,iv,xv,xx1,xx2,obswk,k,-1)
CC     ... pull out second number from verbosity stack
C          call togprt
C          j = iprint()
C          call poppr
C          ifi = fopn('SAVE')
C          call poseof(ifi)
C          call mm_dyn(nbas,xsi,w(owk2),w,w(owk),w,w,nstep,irmmd,w,0,
C     .      w(obswk),w(ofrc),amag,w(oaamom),ehf,s_sdyn,nvarms,ifi)
C          call fclose(ifi)
C          call pshpr(j)
C          call togprt
C          do  36  j = 1, nl
C          call dpscop(w(owk2),w(oeula),nbasp,1,nbasp*(j-1)+1,1d0)
C   36     call dpscop(w(owk2),w(oeula),nbasp,nbasp+1,nbasp*(nl+j-1)+1,
C     .      1d0)
        endif
        call rlse(ofrc)
      endif
#endif

C --- Estimate self-consistent moments from dielectric response ---
      call asalsq(iscr,sctrl,slat,sspec,sarray,sham,sbz,spot,vrl,
     .  w(oqold),w(oqnu))

C ... Update changes in vconst
      call pack1('pot vconst',spot,vconst)

C --- Shift moments to the center of gravity of band ---
      makepp = getdig(sdmod,3,10) .eq. 0
      if (makepp) then
        call mixpqc(nclasp,w(onrcp),nl,nsp,w(ogrp2),w(opnu),w(oqnu))
        call upack1('ham pmin',sham,pmin)
        call shftpq(nclasp,w(onrcp),nsp,nl,w(olmx),w(ormax),avw,w(opp),
     .    w(oqnu),w(oidmod),.false.,pmin,w(opnu),w(oqnu),xv)
      endif

#if LMCNST
C --- Make output ves ---
      call asamad(sctrl,spot,sarray,slat,sspec,0,w(opnu),w(oqnu),
     .          vrl,w(oves),emad,trumad,vmtz)
C --- Map ves into vtil ---
      call defdr(ovtil,nbas)
      call defdr(ovotil,nbas)
      call defdr(omad2,nbas**2)
      call defdr(oumad,nbas**2)
      call defdr(oevmad,nbas)
      call rotmad(nbas,nclasp,w(oipc),wsr,w(omad),w(ovold),w(oves),
     .  w(onrcp),emad0,modcst,w(omad2),w(ogroup),
     .  w(oevmad),w(oumad),w(ovotil),w(ovtil),nvmix)
C --- Mix vtil; back transform to ves ---
      call vmix(nclasp,nl,nsp,nbas,w(oves),w(ovold),w(opp),
     .  w(oiclas),w(onrcp),w(ovtil),w(ovotil),w(oumad),w(oevmad),
     .  modcst,w(ogroup),wsr,w(omad),nvmix,switch(4))
#endif

C --- Mix moments and/or Euler angles ---
      nwmoms = .false.
      if (makepp) then
        dmxprm(9) = betv
C   ... Get mixing string; set up mixing constraint for pqmix
        call upacks('strn mix',i1,i2)
C   ... Save qnu for independent potential mixing
        i = igets('mix lxpot',smix)
        opnus = opnu
        oqnus = oqnu
        if (i .eq. 2) then
          call defdr(opnus,nlspcp)
          call defdr(oqnus,3*nlspcp)
          call dcopy(nlspcp,w(opnu),1,w(opnus),1)
          call dcopy(3*nlspcp,w(oqnu),1,w(oqnus),1)
        endif
C   ... Extra degrees of freedom
        call defi(omxcst, nclasp+1)
        i = 3*nl*nl*nbas
        if (lnsph.ne.0) i = i + nqpp*4*nsp*nbas
        call defrr(oxold, i)
        call defrr(oxnew, i)
        sw = lmfrce .and. getdig(sdmod,1,10).eq.0 .and. neul .gt. 0
        call pvpqm1(0,sspec,nclass,nclasp,nsp,nbas,lpgf,F,lnsph.ne.0,sw,
     .    neul,w(oics),w(oipc),w(omxcst),nqpp,w(oqppo),w(oqpp),w,w,
     .    w(oeulo),w(oeula),vcnsts,vconst,i,w(oxold),w(oxnew))
        dmxprm(34) = dmxprm(4)
        call pqmix(nclasp,nl,w(olmx),nsp,i,nit,sstrn(i1:i2),dmxprm,
     .    w(omxcst),w(opold),w(oqold),w(oxold),w(opnu),w(oqnu),w(oxnew))
        call pvpqm1(1,sspec,nclass,nclasp,nsp,nbas,lpgf,F,lnsph.ne.0,sw,
     .    neul,w(oics),w(oipc),w(omxcst),nqpp,w(oqppo),w(oqpp),w,w,
     .    w(oeulo),w(oeula),vcnsts,vconst,i,w(oxold),w(oxnew))
        call rlse(omxcst)
        betv = dmxprm(9)
C   ... Independent potential mixing
        if (lves .eq. 2) then
C     ... ves [mixed rho or output rho], depending on mix->lxpot
C         NB: Not needed if screened ves available.
C         But this makes ves[screened output rho, so ok.
C         if (mod(iscr/2,2) .eq. 0) then
          call pshpr(iprint()-20)
          call asamad(sctrl,spot,sarray,slat,sspec,0,
     .      w(opnus),w(oqnus),vrl,w(oves),emad,trumad,vmtz)
          call poppr
C         endif
          call vmix2(nclasp,w(oclabl),betv,w(ovold),w(oves))
          if (igets('mix lxpot',smix) .eq. 2) call rlse(opnus)
        endif
        if (procid .eq. master) then
          call shoctl(sctrl,sspec,spot,sarray,1,fopn('LOG'))
        endif
        if (mod(nint(dmxprm(25)),10) .eq. 1) nwmoms = .true.

C     Potential is frozen: keep starting P,Q, d.c. terms
      else
C       call shoctl(sctrl,sspec,spot,sarray,0,stdo)
        call dcopy(nlspcp,w(opold),1,w(opnu),1)
        call dcopy(3*nlspcp,w(oqold),1,w(oqnu),1)
C       call shoctl(sctrl,sspec,spot,sarray,0,stdo)
        call pack1('ham eterms',sham,etrmss)
      endif

C ... Save mixed qpp array
      if (lnsph .ne. 0) call ioqpp(T,sctrl,spot)

C ... Independent mixing of Euler angles (moms into scratch)
      if (lmfrce .and. getdig(sdmod,1,10).eq.1 .and. neul .gt. 0) then
        call upacks('strn amix',i1,i2)
        if (i2 .le. i1) then
          outs = 'A0,b=1,w=0,0,wa=1,fn=ma'
        else
          outs = sstrn(i1:i2)
        endif
        call info0(31,1,0,' Independently mix Euler angles')
        call defdr(owk,nlspcp)
        call defdr(owk2,3*nlspcp)
        call dcopy(nlspcp,w(opnu),1,w(owk),1)
        call dcopy(3*nlspcp,w(oqnu),1,w(owk2),1)
C   ... Pull out regular mixing variables, poke in Euler-specific
        call parms0(dmxprm(27),dmxprm(28),dmxprm(29),1)
        call parms0(dmxprm(30),dmxprm(31),dmxprm(32),-1)
        call defi(omxcst, nclasp+1)
        call defrr(oxold, 3*nl*nl*nbas)
        call defrr(oxnew, 3*nl*nl*nbas)
        call pvpqm1(0,sspec,nclass,nclasp,nsp,nbas,0,F,F,T,neul,w(oics),
     .    w(oipc),w(omxcst),nqpp,w,w,w,w,w(oeulo),w(oeula),vcnsts,
     .    vconst,i,w(oxold),w(oxnew))
        dmxeu(4) = 0
        dmxeu(5) = 0
        dmxeu(34) = 1
        call pqmix(nclasp,nl,w(olmx),nsp,i,nit,outs,dmxeu,
     .    0,w(opnu),w(oqnu),w(oxold),w(owk),w(owk2),w(oxnew))
        call pvpqm1(1,sspec,nclass,nclasp,nsp,nbas,0,F,F,T,neul,w(oics),
     .    w(oipc),w(omxcst),nqpp,w,w,w,w,w(oeulo),w(oeula),vcnsts,
     .    vconst,i,w(oxold),w(oxnew))
        call parms0(dmxprm(30),dmxprm(31),dmxprm(32),1)
        call parms0(dmxprm(27),dmxprm(28),dmxprm(29),-1)
        call rlse(owk)
      endif

C ... Write updated Euler angles to disk
      if (bittst(lncol,1) .and. getdig(sdmod,0,10).ne.3) then
        if (procid .eq. master) then
        ifi = fopn('EULA')
        rewind ifi
        call ioeula(nbasp,nl,w(oeula),neul,0d0,-ifi)
        call fclose(ifi)
        endif
      endif
      call rlse(opold)
C ... Skip over self-consistency when Euler angles are l-dependent
      if (.not. nwmoms) goto 58
      goto 10

   99 continue
C     call tcx('lmasa')

      end

C      subroutine snot(spot)
C      implicit none
C      double precision spot(1),vshft(-7:19),ves(9)
C      integer w(1)
C      common /w/ w
C      integer ovshft
C      call upack1('pot ovshf',spot,ovshft)
C      call dcopy(26,w(ovshft),1,vshft,1)
C      call upack1('pot oves',spot,ovshft)
C      call dcopy(9,w(ovshft),1,ves,1)
C      end

