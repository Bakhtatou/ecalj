      subroutine hstrux(e,nlma,nlmb,nlmx,npow,n1,n2,ikl,jkl,ip,cf,hl,s)
C- Vectorized strux and energy derivatives
C ----------------------------------------------------------------------
Ci Inputs
Ci   e     :energy
Ci   nlma  :Generate S_R'L',RL for L' < nlma
Ci   nlmb  :Generate S_R'L',RL for L  < nlmb
Ci   nlmx  :leading dimension of ikl,jkl,hl; generated by setup strxsu
Ci   npow  :generated by setup strxsu
Ci   n1,n2 :make strux for reduced strux hl(*,n1..n2)
Ci   ikl   :generated by setup strxsu
Ci   jkl   :generated by setup strxsu
Ci   ip    :generated by setup strxsu
Ci   cf    :generated by setup strxsu
Ci   hl    :reduced strux (Hankels for connecting vector; see rstr0.f)
Co Outputs
Co   s     :real-space structure constants
Cr Remarks
Cr    Expansion theorem is:  k(k,r-dr) = sum(m) s(m,k,dr)*j(m,r)
Cr    See mstrx2 for nonvectorized version
Cr
Cr    hstrux requires call to setup routine strxsu, and hl; see rstr0
Cu Updates
C ----------------------------------------------------------------------
C     implicit none
C ... Passed parameters
      integer nlma,nlmb,nlmx,npow,n1,n2
      integer ip(1),ikl(nlmx,0:1),jkl(nlmx,0:1)
      double precision e,hl(nlmx,n2),cf(1),s(nlma,nlmb,1),
     .  efac(0:20)
C ... Local parameters
      integer i,i1,i2,ilm,ipow,k,l,ll,lmax,nlm,n,m
      double precision fpi,xx(4)
c     parameter (tol=1d-12)

C --- Setup ---
      fpi = 16d0*datan(1d0)
      lmax = ll(nlma) + ll(nlmb)
      nlm = (lmax+1)**2
      if (lmax .gt. 20) call rx('hstrux: lmax gt 20')
      efac(0) = 1d0 * fpi
C      edot(0) = 0d0
      do  1  l = 1, lmax
        efac(l) = -e*efac(l-1)
C       edot(l) = -l*efac(l-1)
    1 continue

C --- Loop over ipow,ilm ---
      call dpzero(s, nlma*nlmb*(n2-n1+1))
      do  10  n = n1, n2, 2
        m = n-n1+1
        if (n .eq. n2) then
          do  12  ipow = 0, npow
          do  12  ilm = 1, nlm
            i1 = ikl(ilm,ipow)
            i2 = jkl(ilm,ipow)
            xx(1) = efac(ipow)*hl(ilm,n)
            do  14  i = i1, i2
              k = ip(i)
              s(k,1,m) = s(k,1,m) + xx(1)*cf(i)
   14       continue
   12     continue
        else
          do  22  ipow = 0, npow
          do  22  ilm = 1, nlm
            i1 = ikl(ilm,ipow)
            i2 = jkl(ilm,ipow)
            xx(1) = efac(ipow)*hl(ilm,n)
            xx(2) = efac(ipow)*hl(ilm,n+1)
            do  24  i = i1, i2
              k = ip(i)
              s(k,1,m)   = s(k,1,m)   + xx(1)*cf(i)
              s(k,1,m+1) = s(k,1,m+1) + xx(2)*cf(i)
   24       continue
   22     continue
        endif
   10 continue
      end
      subroutine hstrud(e,nlma,nlmb,nlmx,npow,offh,ikl,jkl,ip,cf,hl,hd,
     .  s,sd)
C- Vectorized strux and energy derivatives
C ----------------------------------------------------------------------
Ci Inputs
Ci   e     :energy
Ci   nlma  :Generate S_R'L',RL for L' < nlma
Ci   nlmb  :Generate S_R'L',RL for L  < nlmb
Ci   nlmx  :leading dimension of ikl,jkl; generated by setup strxsu
Ci   npow  :generated by setup strxsu
Ci   offh  :offset to the reduced strux hl and hd.
Ci   ikl   :generated by setup strxsu
Ci   jkl   :generated by setup strxsu
Ci   ip    :generated by setup strxsu
Ci   cf    :generated by setup strxsu
Ci   hl    :reduced strux (Hankels for connecting vector; see rstr0.f)
Ci   hd    :energy derivative of hl
Co Outputs
Co   s     :real-space structure constants
Co   sd    :energy derivative of s
Cr Remarks
Cr    Exp. theorem is:  k(k,r-dr) = sum(m) s(m,k,dr)*j(m,r)
Cr    See mstrx2 for nonvectorized version
Cr
Cr    hstrud requires call to setup routine strxsu, and hl,hd; see rstr0
Cu Updates
C ----------------------------------------------------------------------
C     implicit none
C ... Passed parameters
      integer nlma,nlmb,nlmx,npow,offh
      integer ip(1),ikl(nlmx,0:1),jkl(nlmx,0:1)
      double precision e,hl(nlmx),hd(nlmx),cf(1),s(nlma,1),sd(nlma,1),
     .  efac(0:20),edot(0:20)
C ... Local parameters
      integer i,i1,i2,ilm,ipow,k,l,ll,lmax,nlm
      double precision fpi,xxd,xxx
c     parameter (tol=1d-12)

C --- Setup ---
      fpi = 16d0*datan(1d0)
      lmax = ll(nlma) + ll(nlmb)
      nlm = (lmax+1)**2
      if (lmax .gt. 20) call rx('hstrud: lmax gt 20')
      efac(0) = 1d0 * fpi
      edot(0) = 0d0
      do  1  l = 1, lmax
        efac(l) = -e*efac(l-1)
        edot(l) = -l*efac(l-1)
    1 continue

C --- Loop over ipow,ilm ---
      call dpzero(s, nlma*nlmb)
      call dpzero(sd,nlma*nlmb)
      do  10  ipow = 0, npow
      do  10  ilm = 1, nlm
        i1 = ikl(ilm,ipow)
        i2 = jkl(ilm,ipow)
        xxx = efac(ipow)*hl(ilm+offh)
        xxd = efac(ipow)*hd(ilm+offh) + edot(ipow)*hl(ilm+offh)
C       if(dabs(xxx).gt.tol .or. (dabs(xxd).gt.tol)) then
          do  12  i = i1, i2
            k = ip(i)
            s(k,1) = s(k,1)  + xxx*cf(i)
            sd(k,1)= sd(k,1) + xxd*cf(i)
   12     continue
C        endif
   10 continue
      end

