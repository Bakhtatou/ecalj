Cgetarg...info...           structure ['sugwin', 'lat', 'slat']
Cgetarg...info...           structure ['sugwin', 'gw', 'sgw']
Cgetarg...info...           structure ['sugwin', 'ham', 'sham']
Cgetarg...info...           structure ['sugwin', 'bz', 'sbz']
Cgetarg...info...           structure ['sugwin', 'site', 'ssite']
Cgetarg...info...           structure ['sugwin', 'spec', 'sspec']
Cgetarg...info...           use_to_add ['sugwin', 'm_struc_def']
      subroutine sugwin(ssite,sspec,slat,sham,sgw,sbz,nbas,qval)
       
       use m_struc_def  !Cgetarg

C- Creates these input files as setup to GW: GWinput, QIBZ 
C ----------------------------------------------------------------------
Ci Inputs
Ci   ssite :struct for site-specific information; see routine usite
Ci     Elts read: spec pnu pz
Ci     Stored:    *
Ci     Passed to: *
Ci   sspec :struct for species-specific information; see routine uspec
Ci     Elts read: lmxa z p pz idxdn
Ci     Stored:    pb1 pb2
Ci     Passed to: *
Ci   slat  :struct for lattice information; see routine ulat
Ci     Elts read: alat plat qlat nabc npgrp nsgrp osymgr
Ci     Stored:    *
Ci     Passed to: *
Ci   sham  :struct for parameters defining hamiltonian; see routine uham
Ci     Elts read: ldham
Ci     Stored:    *
Ci     Passed to: *
Ci   sgw
Ci     Elts read: mksig lgw nkabc nband qoffp gcutb gcutx ecuts nime
Ci                delre deltax deltaw pbtol gsmear
Ci     Stored:
Ci     Passed to:
Ci   sbz   :struct for the Brillouin Zone; see routine ubz
Ci     Elts read: nkabc lshft
Ci     Stored:
Ci     Passed to:
Ci   nbas  :size of basis
Ci   qval  :number of valence electrons (sets number of bands)
Co Outputs
Co    Files GWinput, QIBZ, KPTin1BZ created.
Co    Optionally files Q0P, QGpsi, QGcou are created. (--make-Q0P)
Co      These latter are redundant because they are generated by
Co      the GW code 'qg4gw'.   For the newer offset meshes, this
Co      routine generates the wrong output.
Co     --make-Q0P is useful so that the GW driver can be tested
Co     standalone, without requiring qg4gw.
Cu Updates
Cu   30 Aug 05 sugw handles ngp=0 and/or ngc=0
Cu   04 Jul 05 handle sites with lmxa=-1 -> no rep'sn in GWinput
Cu   24 Oct 01 Adapted from v6.11 sugw
C ----------------------------------------------------------------------
C     implicit none
C ... Passed parameters
      integer nbas,n0,nkap0
      parameter (n0=10,nkap0=3)
Cgetarg       double precision ssite(1),sspec(1),slat(1),sham(1),sgw(1),sbz(1)
       type(s_site)::ssite(*)
       type(s_spec)::sspec(*)
       type(s_lat)::slat
       type(s_ham)::sham
       type(s_gw)::sgw
       type(s_bz)::sbz

      double precision qval
C ... Local parameters
      logical cmdopt,ltmp
      integer fopnx,i,iaf,iat,idxdn(n0,nkap0),ifi,ifii,igets,igetss,ii,
     .  ipr,iq,iq0i,iqall,is,iwk(3),j,jfi,k,k1,k2,k3,konf,konfig(0:n0),
     .  l,lcutmx(nbas),ldham(8,2),ldim,lgunit,lgw,lmaxa,lshft(3),mksig,
     .  n1,n1q,n2,n2q,n3,n3q,nat,nband,ncinc,ncinc2,ncore,ngabc(3),ngc,
     .  ngcmx,nglob,ngp,ngpmx,niw,nkgw(3),nkp,nl,nncx,nnvv(n0,nbas),
     .  nocc,npgrp,npqn,nq0i,nqibz,nqnum,nsgrp,nsp,nunocc,nx0,stdo
      integer og,oipq,okv
      equivalence (n1,ngabc(1)),(n2,ngabc(2)),(n3,ngabc(3))
      equivalence (ldim,ldham(1,1))
      equivalence (n1q,nkgw(1)),(n2q,nkgw(2)),(n3q,nkgw(3))
      integer,allocatable:: ngpn(:,:),ngcn(:,:),ngvecp(:,:),ngvecc(:,:)
      double precision alp,gcutb,gcutx,ecuts,pnu(n0,2),pnz(n0,2),z,
     .  dw(2),delta,deltaw,esmr,tolopt,dgetss,plat(3,3),qlat(3,3),
     .  qb(3,3),xn,alat,q(3),qp(3),xx
      double precision,allocatable:: qbz(:,:),qibz(:,:),wbz(:),
     .  q0x(:,:),q0i(:,:),wt(:),wt0(:)
      character pb1*8,pb2*8,pbi(2,3)*8,outs*80
      character lsym(0:n0-1)*1, lorb(3)*1, dig(9)*1, strn8*8
      data lsym /'s','p','d','f','g','5','6','7','8','9'/
      data lorb /'p','d','l'/
      data dig /'1','2','3','4','5','6','7','8','9'/
C ... Heap
      integer w(1)
      common /w/ w

C --- Setup ---
      call getpr(ipr)
Cgetarg...info...           real(8) :: alat , real(8) :: slat%alat 1
Cgetarg...info...           real(8) :: plat(3,3) , real(8) :: slat%plat 9
Cgetarg...info...           real(8) :: qlat(3,3) , real(8) :: slat%qlat 9
Cgetarg...info...           integer :: ngabc(3) , integer(8) :: slat%nabc 3
Cgetarg       call upack('lat alat plat qlat nabc',slat,alat,plat,qlat,ngabc,0)
       
       alat=slat%alat
       i_copy_size=size(slat%plat) 
       call dcopy(i_copy_size,slat%plat,1,plat,1) 
       i_copy_size=size(slat%qlat) 
       call dcopy(i_copy_size,slat%qlat,1,qlat,1) 
       i_copy_size=size(slat%nabc) 
       call i8icopy(i_copy_size,slat%nabc,1,ngabc,1) 

Cgetarg...info...           integer :: npgrp , integer(8) :: slat%npgrp 1
Cgetarg...info...           integer :: nsgrp , integer(8) :: slat%nsgrp 1
Cgetarg...info...           integer :: og , integer(8) :: slat%osymgr 1
Cgetarg       call upack('lat npgrp nsgrp osymgr',slat,npgrp,nsgrp,og,0,0)
       
       npgrp=slat%npgrp
       nsgrp=slat%nsgrp
       og=slat%osymgr

      call fftz30(n1,n2,n3,k1,k2,k3)
      stdo = lgunit(1)
      nsp  = nglob('nsp')
      nl   = nglob('nl')
Cgetarg       mksig = igets('gw mksig',sgw)
       mksig = int(sgw%mksig) 

      if (cmdopt('--sc',4,0,outs)) then
        if (mksig .eq. 0) mksig = 1
      endif
Cgetarg       lgw = igets('gw lgw',sgw)
       lgw = int(sgw%lgw) 

      if (mksig .ne. 0) lgw = 1
Cgetarg...info...           integer :: nkgw(3) , integer(8) :: sgw%nkabc 3
Cgetarg...info...           integer :: nband , integer(8) :: sgw%nband 1
Cgetarg...info...           real(8) :: alp , real(8) :: sgw%qoffp 1
Cgetarg...info...           real(8) :: gcutb , real(8) :: sgw%gcutb 1
Cgetarg...info...           real(8) :: gcutx , real(8) :: sgw%gcutx 1
Cgetarg       call upack('gw nkabc nband qoffp gcutb gcutx',sgw,nkgw,nband,alp,
Cgetarg      .  gcutb,gcutx)
       
       i_copy_size=size(sgw%nkabc) 
       call i8icopy(i_copy_size,sgw%nkabc,1,nkgw,1) 
       nband=sgw%nband
       alp=sgw%qoffp
       gcutb=sgw%gcutb
       gcutx=sgw%gcutx

Cgetarg...info...           real(8) :: ecuts , real(8) :: sgw%ecuts 1
Cgetarg       call upack1('gw ecuts',sgw,ecuts)
       
       ecuts=sgw%ecuts


Cgetarg...info...           integer :: ldham(8,2) , integer(8) :: sham%ldham 16
Cgetarg       call upack('ham ldham',sham,ldham,0,0,0,0)
       
       i_copy_size=size(sham%ldham) 
       call i8icopy(i_copy_size,sham%ldham,1,ldham,1) 

      call info0(30,0,0,' ... Creating files GWinput, QIBZ, KPTin1BZ')

      if (n1q*n2q*n3q .eq. 0) then
        call info(30,0,0,
     .    ' ... (warning) using k-points from BZ category',0,0)
Cgetarg...info...           integer :: nkgw(3) , integer(8) :: sbz%nkabc 3
Cgetarg...info...           integer :: lshft(3) , integer(8) :: sbz%lshft 3
Cgetarg         call upack('bz nkabc lshft',sbz,nkgw,lshft,0,0,0)
         
         i_copy_size=size(sbz%nkabc) 
         call i8icopy(i_copy_size,sbz%nkabc,1,nkgw,1) 
         i_copy_size=size(sbz%lshft) 
         call i8icopy(i_copy_size,sbz%lshft,1,lshft,1) 

      endif

C ... Count number of atoms : exclude floating orbitals
      nat = 0
      do  i = 1, nbas
Cgetarg...info...           integer :: is , integer(8) :: ssite%spec 1
Cgetarg         call upack('site spec',ssite,i,is,0,0,0)
         
         is=ssite(i)%spec

Cgetarg         lmaxa = igetss('spec lmxa',is,sspec)
         lmaxa = int(sspec(is)%lmxa) 

        if (lmaxa .gt. -1) then
          nat = nat + 1
        endif
      enddo

C ... qp in full BZ, Arysetiawan's order; write file KPTin1BZ
      nkp = n1q*n2q*n3q
      allocate(qbz(3,nkp),wbz(nkp))
      call genqbz(qlat,n1q,n2q,n3q,qbz,wbz)
C     Irreducible qp in BZ
      call iinit(iwk,3)
      call defi(oipq,n1q*n2q*n3q)
      allocate(qibz(3,nkp))
      wbz(1) = 0
      call bzmesh(plat,qb,n1q,n2q,n3q,iwk,w(og),npgrp,w(oipq),
     .  qibz,wbz,nqibz,nkp,0,0)
      call rlse(oipq)
      deallocate(wbz)

C ... Create first part of GWinput
      ltmp = .false.
      if (.not. cmdopt('--no-GWinput',12,0,outs)) then
      ltmp = .true.
      ifii = fopnx('GWinput',2,2,-1)
      rewind ifii
      write(ifii,301)
  301 format(
     .  '! Text following "!" are comments'/
     .  '! Input lines consist of "keyword value(s)"'/
     .  '! New section begins with <tagname>'/
     .  '!Verbose    0   ! 0-->default; 100-->debug'/
     .  '!Q0P_Choice 0   ! 0-->along plat(default);  ',
     .                    '1-->along x,y,z'/
     .  '!CoreOrth  off  ! off --> Do not orthogonalize core to valence'
     .                           ,' (default)'/
     .  '                ! on  --> Orthogonalize cores to valence ',
     .                            '(may give strange core functions!)'/
     .  '!multitet 2 2 2 ! tetrahedra divided into micro-tetrahedra'/
     .  '!EXonly   .15   ! for exchange-only calculations'/
     .  '!TimeReversal off ! when time-reversal symmetry is broken'/
     .  'KeepEigen  on   ! keep eigenfunctions in memory'/
     .  'KeepPPOVL  on   ! keep PPOVL in memory'/
     .  '!Chi_RegQbz on  ! Offset Gamma point mesh for chi.',
     .                  '  on => no offset'/
     .  'BZmesh     1    ! Offset Gamma point mesh for Sigma=iGW'/
     .  'WgtQ0P     0.01 ! Weight used when BZmesh is 2'/
     .  'NormChk    0    ',
     .  '! 1,2 writes norm check files (diagonal or full)'/
     .  '! ##### From GWIN0 ################')
      endif

C ... Create file GWIN0
      if (cmdopt('--make-GWIN',11,0,outs)) then
      ifi = fopnx('GWIN0',2,2,-1)
      rewind ifi
      write(ifi,'(a)') ' n1 n2 n3 : number of k-points for GW'
      write(ifi,'(3I3)') n1q,n2q,n3q
      write(ifi,'(a)') ' Plane wave cut off for |q+G| in a.u. ngp,ngc'
      call awrit2(' %d %d',' ',80,ifi,gcutb,gcutx)
      write(ifi,'(a)') ' Parameter for offset gamma points Q0P'
      call awrit1(' %d',' ',80,ifi,alp)
      write(ifi,'(a)') ' Number of bands'
      call awrit2(' %i %,1d%20pEnergy cutoff for hx0fp0',' ',80,ifi,
     .  9999,999d0)
      call awrit2(' %i %,1d%20pEnergy cutoff for hsfp0',' ',80,ifi,
     .  9999,ecuts)
      call fclr(' ',ifi)
      endif
      if (.not. cmdopt('--no-GWinput',12,0,outs)) then
      write(ifii,'(''n1n2n3'',3I3,'' ! for GW BZ mesh'')') n1q,n2q,n3q
      call awrit1('QpGcut_psi %d %16p!|q+G| cutoff for eigenfunction',
     .  ' ',80,ifii,gcutb)
      call awrit1('QpGcut_cou %d %16p!|q+G| cutoff for coulomb int.',
     .  ' ',80,ifii,gcutx)
      write(ifii,302)
  302 format('unit_2pioa off  ! off --> units of 2 preceding Gcut are ',
     .       'a.u.; on--> units are 2*pi/alat')
      call awrit1('alpha_OffG %d%16p!(a.u.) parameter in the auxiliary'
     .  //' function in the offset-Gamma method',' ',80,ifii,alp)
      write(ifii,303)
  303 format(
     .  '!nband_chi0 999 !nband cutoff for chi0  (Optional)'/
     .  '!emax_chi0 999. !emax  cutoff for chi0, Ry  (Optional)'/
     .  '!nband_sigm 999 !nband cutoff for Sigma (Optional)')
      call awrit1('emax_sigm %d%16p%b !Energy cutoff for Sigma, '//
     .  'Ry (Optional)',' ',80,ifii,ecuts)
      endif

C ... Create file QIBZ
      ifi = fopnx('QIBZ',2,2,-1)
      write(ifi,'(i4)') nqibz
      do  i = 1, nqibz
        write(ifi,'(3e24.16)') qibz(1:3,i)
      enddo
      call fclr(' ',ifi)

C ... Create file QPNT
      if (cmdopt('--make-QPNT',11,0,outs)) then
      ifi = fopnx('QPNT',2,2,-1)
      write(ifi,'(a)') ' --- Specify qp and band indices'//
     .  ' at which to evaluate Sigma'
      write(ifi,*)
      write(ifi,'(a)')
     .  '*** Sigma at all q -->1; to specify q -->0.'//
     .  '  Second arg : up only -->1, otherwise 0'
      iqall = 0
C     if (mksig .ne. 0) iqall = 1
      iaf = 0
      write(ifi,'(2i3)') iqall, iaf
      write(ifi,'(a)')
     .  '*** no. states and list of band indices to make Sigma '//
     .  'and QP energies'
      j = nint(qval/2+4)
C     if (mksig .ne. 0) j = ldim
      write(ifi,'(i3)')  j
      write(ifi,'(99i3)') (i,i=1,j)
      write(ifi,'(a)') '*** q-points'//
     .  ' (must belong to mesh of points in BZ).'
      write(ifi,'(i3)') min(nqibz,3)
      write(ifi,'(i3,3f23.16)') (i,qibz(1:3,i),i=1,nqibz)
      call fclr(' ',ifi)
      endif

C ... Create file GWIN_V2
      if (.not. cmdopt('--no-GWinput',12,0,outs)) then
Cgetarg...info...           integer :: niw , integer(8) :: sgw%nime 1
Cgetarg...info...           real(8) :: dw(2) , real(8) :: sgw%delre 2
Cgetarg...info...           real(8) :: delta , real(8) :: sgw%deltax 1
Cgetarg...info...           real(8) :: deltaw , real(8) :: sgw%deltaw 1
Cgetarg...info...           real(8) :: tolopt , real(8) :: sgw%pbtol 1
Cgetarg       call upack('gw nime delre deltax deltaw pbtol',sgw,niw,dw,
Cgetarg      .  delta,deltaw,tolopt)
       
       niw=sgw%nime
       i_copy_size=size(sgw%delre) 
       call dcopy(i_copy_size,sgw%delre,1,dw,1) 
       delta=sgw%deltax
       deltaw=sgw%deltaw
       tolopt=sgw%pbtol

Cgetarg...info...           real(8) :: esmr , real(8) :: sgw%gsmear 1
Cgetarg       call upack1('gw gsmear',sgw,esmr)
       
       esmr=sgw%gsmear

C     write(ifi,'(a)') '! Input from GWIN_V2'
      call awrit1('dw       %d%16p!mesh spacing along Real axis (Ry)',
     .  ' ',80,ifii,dw)
      call awrit1('omg_c    %d%16p!Used in S. Faleev''s real-axis mode',
     .  ' ',80,ifii,dw(2))
      call awrit1('iSigMode %i%16p!QSGW mode switch (QSGW only)',
     .  ' ',80,ifii,mksig)
      call awrit1('niw      %i%16p!# freq. on Im axis; used for '//
     .  'integration to make Sigma_c',' ',100,ifii,niw)
      call awrit1('delta    %g%16p!delta-function broadening for calc.'
     .  //' x0, a.u.. delta<0 => tetrahedron',' ',100,ifii,delta)
      call awrit1('deltaw   %g%16p!width in finite diff for sigma '
     .  //'energy derivative, a.u.',' ',100,ifii,deltaw)
      call awrit1('esmr     %g%16p!Broadening in the poles of '
     .  //'G(LDA) (hsfp0)',' ',100,ifii,esmr)
      write(ifii,304)
  304 format(16x,'!Change esmr for metals: ',
     .  'see DOSACC* --- especially around Ef'/
     .  'GaussSmear on   ',
     .  '!on  => broadening of poles in G(LDA) by Gaussian'/16x,
     .  '!off => broadening of poles by a rectangle'/
     .  '!mixbeta   .25  ',
     .  '!mixing of input, output sigma for self-consistency')
      write(ifii,305) 'PRODUCT_BASIS',
     .  '! Product basis block exactly as in GWIN_V2'
  305 format(/'! #################################################'/
     .  '<',a,'>':,3x,a)
  306 format('</',a,'>')
      endif

      if (cmdopt('--make-GWIN',11,0,outs)) then
      ifi = fopnx('GWIN_V2',2,2,-1)
      rewind ifi
Cgetarg...info...           integer :: niw , integer(8) :: sgw%nime 1
Cgetarg...info...           real(8) :: dw(2) , real(8) :: sgw%delre 2
Cgetarg...info...           real(8) :: delta , real(8) :: sgw%deltax 1
Cgetarg...info...           real(8) :: deltaw , real(8) :: sgw%deltaw 1
Cgetarg...info...           real(8) :: tolopt , real(8) :: sgw%pbtol 1
Cgetarg       call upack('gw nime delre deltax deltaw pbtol',sgw,niw,dw,
Cgetarg      .  delta,deltaw,tolopt)
       
       niw=sgw%nime
       i_copy_size=size(sgw%delre) 
       call dcopy(i_copy_size,sgw%delre,1,dw,1) 
       delta=sgw%deltax
       deltaw=sgw%deltaw
       tolopt=sgw%pbtol

Cgetarg...info...           real(8) :: esmr , real(8) :: sgw%gsmear 1
Cgetarg       call upack1('gw gsmear',sgw,esmr)
       
       esmr=sgw%gsmear


      write(ifi,'(a)') ' --- FREQUENCIES ---'
C     dw = 0.04d0
      write(ifi,'(1x,a,a,/1p,2e14.5,i4,a)')
     .  'dw = mesh size dw along Real axis (Hartree) ',
     .  'and omg_c parameter (Hartree) for nonlinear part',
     .  dw,mksig,'  ! hchknw generates nw from dw and writes to file NW'
C     niw = 6
      write(ifi,'(1x,a,a/I4)') 'niw = no. frequencies along Im axis.',
     .  '  Used in hsfp0 to make SEC*.',niw
C     delta = -1d-8
      write(ifi,'(1x,a/1pe14.5,a)')
     .  'delta = delta-function broadening for calc. x0.'//
     .  ' delta<0 => use tetrahedron integration',
     .  delta,' ! used by hx0fp0 (Hartree)'
C     deltaw= 0.02d0
      write(ifi,'(1x,a/1pe14.5,a)')
     .  'deltaw  = width in finite diff for sigma energy derivative',
     .  deltaw,' ! used by hsfp0 (Hartree)'
C     esmr  = 0.01d0
      write(ifi,'(1x,a/1pe14.5,a)')
     .  'esmr = smearing in the pole of the Green''s function',
     .  esmr, ' GaussSmear !  used by hsfp0 (Ry)'
      write(ifi,*) 'dummy line'
      write(ifi,*) 'dummy line'
      write(ifi,*)
      write(ifi,*) '--- PRODUCT BASIS ---'
C     tolopt =1d-4
      endif

C ... Write to both GWIN_V2 and GWinput
      do  ii = 1, 2
      if (ii .eq. 1 .and. cmdopt('--make-GWIN',11,0,outs) .or.
     .    ii .eq. 2. and. .not. cmdopt('--no-GWinput',12,0,outs)) then
      if (ii .eq. 1) jfi = ifi
      if (ii .eq. 2) jfi = ifii
      write(jfi,'(1x,a/1pe14.5)')
     .  ' tolerance = minimum eigenvalue in PB overlap',tolopt
      write(jfi,*) ' lcutmx(atom) = l-cutoff for the product basis'
      iat = 0
      do  i = 1, nbas
Cgetarg...info...           integer :: is , integer(8) :: ssite%spec 1
Cgetarg         call upack('site spec',ssite,i,is,0,0,0)
         
         is=ssite(i)%spec

Cgetarg         lmaxa = igetss('spec lmxa',is,sspec)
         lmaxa = int(sspec(is)%lmxa) 

Cgetarg         z =     dgetss('spec z',is,sspec)
         z = (sspec(is)%z) 

        if (lmaxa .gt. -1) then
          iat = iat + 1
          lcutmx(iat) = lmaxa
          if (z .eq. 0) lcutmx(iat) = min(lmaxa,3)
        endif
      enddo
      write(jfi,'(10i3)') lcutmx(1:nat)

      write(jfi,'(1x,a,a,a)')
     .  ' atom   l  nnvv  nnc ! nnvv: num. radial',
     .  ' functions (valence) for augmentation-waves.',
     .  ' nnc = num. for core.'
      nnvv = 2
      do  i = 1, nbas
Cgetarg...info...           integer :: is , integer(8) :: ssite%spec 1
Cgetarg...info...           real(8) :: pnu(n0,2) , real(8) :: ssite%pnu 20
Cgetarg...info...           real(8) :: pnz(n0,2) , real(8) :: ssite%pz 20
Cgetarg         call upack('site spec pnu pz',ssite,i,is,pnu,pnz,0)
         
         is=ssite(i)%spec
         i_copy_size=size(ssite(i)%pnu) 
         call dcopy(i_copy_size,ssite(i)%pnu,1,pnu,1) 
         i_copy_size=size(ssite(i)%pz) 
         call dcopy(i_copy_size,ssite(i)%pz,1,pnz,1) 

Cgetarg         lmaxa = igetss('spec lmxa',is,sspec)
         lmaxa = int(sspec(is)%lmxa) 

        if (lmaxa .gt. -1) then
          call atwf(0,w,lmaxa,w,nsp,pnu,pnz,w,w,w,w,w,k,ncore,konfig,w,
     .      w,w)
          do  l = 0, lmaxa
            if (pnz(l+1,1) .ne. 0) nnvv(l+1,i) = 3
            konf = pnu(l+1,1)
            if (pnz(l+1,1) .ne. 0)
     .        konf = min(int(pnu(l+1,1)),int(mod(pnz(l+1,1),10d0)))
            nncx = konf - l - 1
            write(jfi,'(4i5)') i,l,nnvv(l+1,i),nncx
          enddo
          do  l = lmaxa+1, nl-1
            write(jfi,'(4i5)') i,l,0,0
          enddo
        endif
      enddo

C     if (ii .eq. 1) then
      call info(30,1,0,
     .  ' Creating in GWIN_V2,GWinput the following product basis:',0,0)
      call info(30,0,0,
     .  ' site%2fphi(o)%5fphi(u)%5fdot(o)%5fdot(u)%5floc(o)%5floc(u)',
     .  0,0)
C      endif

      write(jfi,*) ' atom   l    n  occ  unocc  :Valence(1=yes, 0=no)'
      do  i = 1, nbas
        strn8 = '     *'
        pbi = '  ------'
        pbi = '        '
Cgetarg         is = igetss('site spec',i,ssite)
         is = int(ssite(i)%spec) 

Cgetarg         z =  dgetss('spec z',is,sspec)
         z = (sspec(is)%z) 

Cgetarg...info...           integer :: lmaxa , integer(8) :: sspec%lmxa 1
Cgetarg...info...           real(8) :: pnu(n0,2) , real(8) :: sspec%p 20
Cgetarg...info...           real(8) :: pnz(n0,2) , real(8) :: sspec%pz 20
Cgetarg...info...           integer :: idxdn(n0,nkap0) , integer(8) :: sspec%idxdn 30
Cgetarg         call upack('spec lmxa p pz idxdn',sspec,is,lmaxa,pnu,pnz,idxdn)
         
         lmaxa=sspec(is)%lmxa
         i_copy_size=size(sspec(is)%p) 
         call dcopy(i_copy_size,sspec(is)%p,1,pnu,1) 
         i_copy_size=size(sspec(is)%pz) 
         call dcopy(i_copy_size,sspec(is)%pz,1,pnz,1) 
         i_copy_size=size(sspec(is)%idxdn) 
         call i8icopy(i_copy_size,sspec(is)%idxdn,1,idxdn,1) 

Cgetarg         call spacks(0,'spec pb1',sspec,pb1,is,is)
         do i_spacks=is,is 
         call spacks_copy('u',sspec(i_spacks)%pb1,is,is,pb1,i_spacks)
         enddo

Cgetarg         call spacks(0,'spec pb2',sspec,pb2,is,is)
         do i_spacks=is,is 
         call spacks_copy('u',sspec(i_spacks)%pb2,is,is,pb2,i_spacks)
         enddo

        if (lmaxa .gt. -1) then
        do  l = 0, lmaxa
        npqn = 2
        if (pnz(l+1,1) .ne. 0) npqn = 3
        do  k = 1, npqn

C         Read PB1 or set default values for those not specified
          if (pb1(l+1:l+1) .ne. ' ') then
            read(pb1(l+1:l+1),'(I1)') nocc
          else
            nocc = 1
C           default occ PB 0 for f orbitals or higher
            if (l .gt. 2) nocc = 0
            if (l .gt. 1 .and. z .eq. 0) nocc = 0

C           default occ PB 0 for dot function, no local orbital
            if (npqn .eq. 2) then
              if (k .ge. 2) nocc = 0
C           default occ PB 0 for dot function w/ local orbital
            else
C             High local orbital
              if (mod(pnz(l+1,1),10d0) .gt. pnu(l+1,1)) then
                if (k .ge. 2) nocc = 0
              endif
            endif
          endif

C         Read PB2 or set default values for those not specified
          if (pb2(l+1:l+1) .ne. ' ') then
            read(pb2(l+1:l+1),'(I1)') nunocc
          else
            nunocc = 1
C           default unocc PB 0 for g orbitals or higher
            if (l .gt. 3) nunocc = 0
            if (l .gt. 2 .and. z .eq. 0) nunocc = 0
C           default unocc PB 0 for dot- functions
            if (k .eq. 2 .and. npqn .eq. 2) nunocc = 0
          endif

C         Write pb1..3 as guide to GWIN_V2
          j = l+1
          write(pbi(1,k)(j:j),'(I1)') nocc
          write(pbi(2,k)(j:j),'(I1)') nunocc
          if (l.le.lmaxa .and. k.eq.1) then
            write(pbi(1,3)(j:j),'(''-'')')
            write(pbi(2,3)(j:j),'(''-'')')
          endif

C         Create string for comment appended to PB line
          konf = pnu(l+1,1)
          if (k .eq. 3) konf = mod(pnz(l+1,1),10d0)
          strn8(1:4) = dig(konf)//lsym(l)//'_'//lorb(k)
          if (idxdn(l+1,1) .eq. 1 .or. idxdn(l+1,2) .eq. 1)
     .      call chcase(0,1,strn8(2:2))

          write(jfi,'(5i5,3x,''! '',a6)') i,l,k,nocc,nunocc,strn8
          strn8 = '     '
        enddo
        enddo
        if (ipr .ge. 30) then
          write(stdo,'(i4,20(3x,a))') i,(pbi(1,k),pbi(2,k),k=1,3)
        endif
        endif
      enddo

      write(jfi,*) ' atom   l    n  occ unocc   ',
     .  'ForX0 ForSxc :CoreState(1=yes, 0=no)'
      do  i = 1, nbas
Cgetarg...info...           integer :: is , integer(8) :: ssite%spec 1
Cgetarg...info...           real(8) :: pnu(n0,2) , real(8) :: ssite%pnu 20
Cgetarg...info...           real(8) :: pnz(n0,2) , real(8) :: ssite%pz 20
Cgetarg         call upack('site spec pnu pz',ssite,i,is,pnu,pnz,0)
         
         is=ssite(i)%spec
         i_copy_size=size(ssite(i)%pnu) 
         call dcopy(i_copy_size,ssite(i)%pnu,1,pnu,1) 
         i_copy_size=size(ssite(i)%pz) 
         call dcopy(i_copy_size,ssite(i)%pz,1,pnz,1) 

Cgetarg         lmaxa = igetss('spec lmxa',is,sspec)
         lmaxa = int(sspec(is)%lmxa) 

        if (lmaxa .gt. -1) then
          call atwf(0,w,lmaxa,w,nsp,pnu,pnz,w,w,w,w,w,k,ncore,konfig,w,
     .      w,w)
          strn8 = '   *'
          do  l = 0, lmaxa
            do  konf = l+1, mod(konfig(l),10)-1
              nocc = 0
              nunocc = 0
              ncinc = 0
              ncinc2 = 0
              strn8(1:2) = dig(konf)//lsym(l)
              call chcase(0,1,strn8(2:2))
              write(jfi,'(5i5,2x,2i5,''    ! '',a)')
     .          i,l,konf-l,nocc,nunocc,ncinc,ncinc2, strn8(1:4)
              strn8 = ' '
            enddo
          enddo
        endif
      enddo
      if (ii .eq. 1) then
        call fclr(' ',ifi)
      endif
      if (ii .eq. 2) then
        write(ifii,306) 'PRODUCT_BASIS'
      endif
      endif
      enddo

C ... Write QPNT to GWinput
      if (.not. cmdopt('--no-GWinput',12,0,outs)) then
      write(ifii,305) 'QPNT','! QPNT block exactly as in file QPNT'
      ifi = ifii
      write(ifi,'(a)') ' --- Specify qp and band indices'//
     .  ' at which to evaluate Sigma'
      write(ifi,*)
      write(ifi,'(a)')
     .  '*** Sigma at all q -->1; to specify q -->0.'//
     .  '  Second arg : up only -->1, otherwise 0'
      iqall = 0
C     if (mksig .ne. 0) iqall = 1
      iaf = 0
      write(ifi,'(2i3)') iqall, iaf
      write(ifi,'(a)')
     .  '*** no. states and list of band indices to make Sigma '//
     .  'and QP energies'
      j = nint(qval/2+4)
C     if (mksig .ne. 0) j = ldim
      write(ifi,'(i3)')  j
      write(ifi,'(99i3)') (i,i=1,j)
      write(ifi,'(a)') '*** q-points'//
     .  ' (must belong to mesh of points in BZ).'
      write(ifi,'(i3)') min(nqibz,3)
      write(ifi,'(i3,3f23.16)') (i,qibz(1:3,i),i=1,nqibz)
      write(ifii,306) 'QPNT'
      endif

C ... Write EPScond to GWinput
      if (.not. cmdopt('--no-GWinput',12,0,outs)) then
        write(ifii,307)
  307   format(
     .  'QforEPSIBZ off'/
     .  '<QforEPS>'/
     .  '0d0 0d0 0.015d0'/
     .  '</QforEPS>'/
     .  'EPSrange  1    !(Ry) [0,EPSrange] for dielectric function'/
     .  'EPSdw     0.05 !(Ry) energy mesh  for dielectric function')
      endif

C --- Special gamma-points ---
      if (cmdopt('--make-Q0P',10,0,outs)) then
      call info(30,1,0, '... Creating files Q0P, QGpsi, QGcou',0,0)
C      call info(30,1,0,'Special gamma-points (file Q0P)',0,0)
      nx0 = 1
      xn  = 3d0
      allocate(q0x(3,6*nx0), wt0(6*nx0), wt(6*nx0), q0i(3,6*nx0))
      call suq0x(alat,plat,alp,qbz,nkp,nx0,xn,q0x,wt0)
C     No support for point groups yet ... use space group
Cgetarg...info...           integer :: nsgrp , integer(8) :: slat%nsgrp 1
Cgetarg...info...           integer :: og , integer(8) :: slat%osymgr 1
Cgetarg       call upack('lat nsgrp osymgr',slat,nsgrp,og,0,0,0)
       
       nsgrp=slat%nsgrp
       og=slat%osymgr

      call q0irre(q0x,wt0,nx0*6,w(og),nsgrp,q0i,nq0i,wt)
C     Open the file with no case change or extension added
      ifi = fopnx('Q0P',2,2,-1)
      write(ifi,'(i5)') nq0i
      write(ifi,'(e24.16,3x,3e24.16)') (wt(i),q0i(1:3,i),i=1,nq0i)
      call fclr('Q0P',ifi)

C ... PW cutoffs for each qp in BZ for each of nq0i shifted meshes
      allocate(ngpn(n1q*n2q*n3q,nq0i+1), ngcn(n1q*n2q*n3q,nq0i+1))
      if (ipr .ge. 100) write(stdo,369)
  369 format(/' G cutoffs for each q0i and qp in BZ'/18x,'qp',20x,
     .  ' ngp  ngc')
      do  iq0i  = 1, 1 + nq0i
        if (ipr .ge. 100) then
          if (iq0i .eq. 1) write(stdo,*) '   no offset'
          if (iq0i .gt. 1) write(stdo,'(/''   offset q0i='',3f12.6)')
     .      q0i(1:3,iq0i-1)
        endif
        do  iq  = 1, n1q*n2q*n3q
          call dcopy(3,qbz(1,iq),1,q,1)
          if (iq0i .gt. 1) call daxpy(3,1d0,q0i(1,iq0i-1),1,q,1)
          call iinit(iwk,3)
          call pshpr(0)
          if (gcutb .gt. 0) then
            call gvlst2(alat,plat,q,iwk(1),iwk(2),iwk(3),0d0,gcutb,0,
     .        100,1,ngpn(iq,iq0i),xx,xx,xx,xx)
          else
            ngpn(iq,iq0i) = 0
          endif
          call iinit(iwk,3)
          if (gcutx .gt. 0) then
            call gvlst2(alat,plat,q,iwk(1),iwk(2),iwk(3),0d0,gcutx,0,
     .        100,1,ngcn(iq,iq0i),xx,xx,xx,xx)
          else
            ngcn(iq,iq0i) = 0
          endif
          call poppr
          if (ipr .ge. 100)
     .    write(stdo,'(3f12.6,3x,2i5)') q ,ngpn(iq,iq0i),ngcn(iq,iq0i)
        enddo
      enddo
      ngpmx = maxval(ngpn)
      ngcmx = maxval(ngcn)
      if (ipr .ge. 20) call awrit2('%N maximum number of PW = %i for '
     .  //'basis,  %i for coulomb',' ',80,stdo,ngpmx,ngcmx)

      ifi = fopnx('QGpsi',2,4,-1)
      rewind ifi
      nqnum = (n1q*n2q*n3q) * (1+nq0i)
      write(ifi) nqnum,ngpmx,gcutb, n1q*n2q*n3q !takao 2003 Sep.

      ifi = fopnx('QGcou',2,6,-1)
      rewind ifi
      write(ifi) nqnum,ngcmx,gcutx

      do  iq0i  = 1, 1+nq0i
      do  iq = 1, n1q*n2q*n3q

C       True q, as distinct from -q in LMTO.ver.4 used by Ferdi's hx0kw
        call dcopy(3,qbz(1,iq),1,q,1)
        if (iq0i .gt. 1) call daxpy(3,1d0,q0i(1,iq0i-1),1,q,1)
        call shorbz(q,qp,qlat,plat)


        ngp = ngpn(iq,iq0i)
        ngc = ngcn(iq,iq0i)
        allocate( ngvecp(3,max(ngp,1)),ngvecc(3,max(ngc,1)) )
        call iinit(iwk,3)
        call pshpr(0)
        call defi(okv,3*max(ngp,ngc))
        if (gcutb .gt. 0) then
          call gvlst2(alat,plat,q,iwk(1),iwk(2),iwk(3),0d0,gcutb,0,102,
     .      1,ngpn(iq,iq0i),w(okv),xx,xx,ngvecp)
        else
          ngvecp = 0
        endif
        call iinit(iwk,3)
        if (gcutx .gt. 0) then
          call gvlst2(alat,plat,q,iwk(1),iwk(2),iwk(3),0d0,gcutx,0,102,
     .      1,ngcn(iq,iq0i),w(okv),xx,xx,ngvecc)
        else
          ngvecc = 0
        endif
        call rlse(okv)
        call poppr
        if (ngp .ne. ngpn(iq,iq0i) .or. ngc .ne. ngcn(iq,iq0i))
     .    call rx('bug in sugwin')

        ifi = fopnx('QGpsi',2,4,-1)
        write (ifi) q, ngp
        write (ifi) ngvecp

        ifi = fopnx('QGcou',2,4,-1)
        write (ifi) q, ngc
        write (ifi) ngvecc

        deallocate(ngvecp,ngvecc)

      enddo ! Loop over qp
      enddo ! Loop over nq0i

      ifi = fopnx('QGpsi',2,4,-1)
      call fclr(' ',ifi)
      ifi = fopnx('QGcou',2,4,-1)
      call fclr(' ',ifi)
      endif

Cgetarg       end
       end subroutine sugwin 


