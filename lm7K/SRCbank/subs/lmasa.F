Cgetarg...info...           structure ['lmasa', 'mix', 'smix']
Cgetarg...info...           structure ['lmasa', 'ctrl', 'sctrl']
Cgetarg...info...           structure ['lmasa', 'ham', 'sham']
Cgetarg...info...           structure ['lmasa', 'pot', 'spot']
Cgetarg...info...           structure ['lmasa', 'array', 'sarray']
Cgetarg...info...           structure ['lmasa', 'lat', 'slat']
Cgetarg...info...           structure ['lmasa', 'bz', 'sbz']
Cgetarg...info...           use_to_add ['lmasa', 'm_struc_def']
      subroutine lmasa(prgnam,sbz,sctrl,sham,spot,slat,smix,
     .  sspec,ssite,sstr,sarray,sstrn)
       
       use m_struc_def  !Cgetarg

C- ASA self-consistency loop
C ----------------------------------------------------------------------
Ci Inputs
Ci   prgnam:nam of main program
Ci   sbz   :struct for the Brillouin Zone; see routine ubz
Ci     Elts read: nkp
Ci     Stored:    *
Ci     Passed to: asars getzv bndasa asasx
Ci
Ci   sctrl :struct for program flow parameters; see routine uctrl
Ci     Elts read: nbas nclass nl nspec nspin loptc lasa lsx lncol lpgf
Ci                sdmod sdprm maxit zbak lcgf lscr lrs,7 lves,18+16 tol
Ci                quit nvario
Ci     Stored:    lscr lasa
Ci     Passed to: lgors supot asars lsets subasi getzv asamad asvsph
Ci                nwit suham bndasa asasx shoctl asalsq ioqpp
Ci
Ci   sham  :struct for parameters defining hamiltonian; see routine uham
Ci     Elts read: oeula neula ehk thrpv seref amgm
Ci     Stored:    *
Ci     Passed to: subasi asvsph suham bndasa asasx asalsq
Ci
Ci   spot  :struct for information about the potential; see routine upot
Ci     Elts read: opp osop ogrrme opnu oqnu oqc oqt orhrmx oves ovrmax
Ci                opmpol oqpp ovintr orhos oaamom
Ci     Stored:    ovdif
Ci     Passed to: supot asars asamad asvsph suham bndasa asasx shoctl
Ci                asalsq ioqpp
Ci
Ci   slat  :struct for lattice information; see routine ulat
Ci     Elts read: avw
Ci     Stored:    *
Ci     Passed to: supot asars asamad asvsph suham bndasa asasx asalsq
Ci
Ci   smix  :struct for charge mixing parameters; see routine umix
Ci     Elts read: b bv w wc nsave mmix
Ci     Stored:    *
Ci     Passed to: *
Ci
Ci   sspec :struct for species-specific information; see routine uspec
Ci     Elts read: idmod z lmxa grp2
Ci     Stored:    *
Ci     Passed to: asars subasi asamad asvsph suham bndasa asasx shoctl
Ci                asalsq pvpqm1
Ci
Ci   ssite :struct for site-specific information; see routine usite
Ci     Elts read: *
Ci     Stored:    *
Ci     Passed to: asars suham bndasa asasx magtrq
Ci
Ci   sstr  :struct for parameters for screened strux; see routine ustr
Ci     Elts read: n sxopt mix amix
Ci     Stored:    *
Ci     Passed to: *
Ci
Ci   sarray:structure containing offsets to various arrays
Ci     Elts read: ohave oics oclabl onrcp oipc npadl npadr nclasp ormax
Ci                ogroup
Ci     Stored:    *
Ci     Passed to: asamad asvsph suham bndasa asasx shoctl asalsq
Ci
Ci   sstrn :struct for global strings
Ci     Elts read: sxopt mix amix
Ci     Stored:    *
Ci     Passed to: suham bndasa asasx
Co Outputs
Cr Remarks
Cr  This is the entry point for the self-consistent ASA band program
Cr
Cr  lmasa contains two main blocks.  One part generates the potential
Cr  from input moments and generates potential parameters as output.
Cr  The ASA interatomic electrostatic potential is generated by asamad,
Cr  while asvsph handles the sphere part.
Cr
Cr  The other block generates eigenvalues, Green's functions, and
Cr  the like from input potential parameters.  One output of
Cr  these blocks are moments, which complete the cycle.  The
Cr  routines generating outputs of the hamiltonian are:
Cr     bndasa:  Eigenvectors and output moms from the ASA hamiltonian.
Cr     gfasa:   crystal Green's function
Cr     pgfasa:  layer Green's function
Cr  Also:
Cr     asasx:   Rucker's screened exchange potential is implemented to
Cr              date and requires output of bndasa.
Cr     magtrq:  generates magnetic forces, rotates magnetic spins
Cr              based on output from noncollinear bndasa, gfasa.
Cr
Cr  The first band iteration is nit=1.  It is possible to do
Cr  a band calculation without moments as input, provided pot. pars.
Cr  are supplied.
Cr
Cl Local variables
Cl   ehterm: parameters needed to make Harris energy
Cl            (1) etot for VH(rmt)=0 (2) sumeV(VH=0)
Cl            (3) sum Q_R V_R        (4) emad
Cl            (5) int input applied field * input density
Cl            (6) int input applied field * output density
Cl          NOTE: this array is archaic.  Will be superseded
Cl                by sham->eterms when the latter is stabilized.
Cl   latok :1s digit
Cl           0 input potential not read or created
Cl           1 input potential is available
Cl         10s digit
Cl          0 parameters to gen. total energy available
Cl          1 parameters to gen. total energy not available
Cl   makepp: F do not update potential or make ppars
Cl           T update potential and make ppars from moments
Cl   etrmss: backup double-counting terms sham->eterms, used
Cl         : when potential, P,Q are kept frozen (see makepp=F)
Cl         : in e.g. frozen-potential SD
Cl   nwmoms: T output moments have been generated
Cl   sdmod : see doc/nc.txt.
Cl           1s digit:
Cl            0 Output Euler angles from density matrix
Cl            1 relax along force
Cl            2 dynamics
Cl           10s digit (for spin statics only)
Cl            0 mix Euler angles with charge moments P,Q
Cl            1 independently mix Euler angles
Cl           1000s digit
Cl            causes lm to prevent updating of atomic P and Q,
Cl            and the potential parameters.
Cl  vconst  :(gf,pgf) Constant estat potential shifts, used where
Cl          : the Fermi level is specified and the potential
Cl          : adjusts to it.
Cl          : vconst(1) = potential shift
Cl          : vconst(2) = potential shift of L end region (PGF)
Cl          : vconst(3) = potential shift of R end region (PGF)
Cl   vrl    : Difference in estat potential in the left- and right- electrodes
Cl          : Consider the equilibrium case first.
Cl          : Right now, the code solves the electrostatics by Ewald
Cl          : summation using periodic boundary conditions.  To make the
Cl          : potential continuous everywhere, an additional linear
Cl          : solution V(z)=[vconst(3)-vconst(2)]*z/Lz is required.  This
Cl          : drop in potential will be distributed properly by the
Cl          : self-consistency condition, satisfying boundary conditons
Cl          : that the potential difference across the leads is
Cl          : [vconst(3)-vconst(2)].  Thus, the potential is continuous.
Cl
Cl          : In the nonequilibrium case, the bias across the device 
Cl          : creates a difference in Fermi level across the left and right
Cl          : leads.  Combining the two effects,
Cl          : vrl = [vconst(3)-vconst(2)] + ef(R)-efermi, where 
Cl          : ef(R) and efermi are fermi energies of right and left leads.
Cu Updates
Cu   08 Nov 07 (J. Xu) New LDA+U ASA hamiltonian
Cu   19 Jul 07 (S.Faleev) corrected electrostatics in pgf case, when
Cu             left- and right- leads are different
Cu   17 Mar 05 (T.Sandu) GF can generate SX sigma
Cu   10 Jul 04 (S.Faleev) Changes to handle non-equilibrium mode
Cu   21 Apr 04 Additions for an m-dependent spin-density matrix
Cu   23 Sep 03 SX patterned after GW.  sigm(irr k) generated
Cu             and stored in file sigm.  sigm(rs) obtained
Cu             by call to rdsigh.
Cu   04 Sep 03 Expand dxmprm so wa may have independent value
Cu   30 Apr 03 Added MPI read/write for rsta.
Cu   20 Mar 03 Added etol as a tolerance for self-consistency
Cu   10 Mar 03 First cut at making proper Kohn-Sham energy.
Cu   17 Feb 03 Added double-counting terms for applied field
Cu   27 Jan 03 Changes to noncollinear code
Cu   24 May 02 small changes to better decouple sx and scr modes
Cu   01 Mar 02 revisions to accomodate changes to PGF codes
Cu   19 Feb 02 revisions to accomodate changes to GF codes
Cu   07 Jun 01 use call to nwit to check convergence
Cu   17 May 01 First attempt for I/O from rst file
Cu   17 Sep 99 start streamlining with sham,spot,fewer passed arguments
Cu   28 Apr 98 add code for radial matrix elements of grad
C ----------------------------------------------------------------------
C     implicit none
C ... Passed parameters:
      character*(*) sstrn, prgnam*8
Cgetarg       double precision sarray(1),sbz(1),sctrl(1),slat(1),smix(1),
Cgetarg      .  sspec(1),ssite(1),sham(1),spot(1),sstr(1)
       type(s_array)::sarray
       type(s_bz)::sbz
       type(s_ctrl)::sctrl
       type(s_lat)::slat
       type(s_mix)::smix
       type(s_spec)::sspec(*)
       type(s_site)::ssite(*)
       type(s_ham)::sham
       type(s_pot)::spot
       type(s_str)::sstr

C ... Heap
      integer w(1)
      common /w/ w
C ... Local variables
      character*120 outs, sxopts*120
C     character ch*1
      logical bittst,cmdopt,lgors,T,F,makepp,nwmoms,lmfrce,aintra,
     .  sw,lfree
      parameter (T=.true., F=.false.)
      integer oeband,oqold,oeula,oeulo,ofrc,ogroup,oics,oidmod,oinitc,
     .  oipc,olmx,onrcp,opnu,opold,opnus,opp,oqc,oqnu,oqnus,oqt,orhos,
     .  orhrmx,ormax,osop,ogrrme,opmpol,ovdif,oves,ovintr,ovold,ovrmax,
     .  owk,owk2,oz,oaamom,oclabl,odq,oxold,oxnew,omxcst
      integer a2vec,bitand,fopn,fopna,fxst,getdig,i,i1,i2,ifi,igets,
     .  imake,stdo,nglob,lham,lves,iprint,iprt,isw,iv(10),lgunit,lasa,
     .  lpgf,lcgf,lncol,lsx,lnsph,loptc,nband,nbas,nclasp,nclspp,nclass,
     .  nevmx,nl,nlspcp,nsp,nspec,sdmod,iscr,neul,nrhos,latok,iscsav
      integer mpipid,procid,master
      double precision ehterm(6),thrpv,amgm,sumev,sevat,etol,ehf,ehk,
     .  ehk0,seref,amag(3),efermi(2),emad,trumad,vmtz(2),zval,zbak(2),
     .  avw,dgets,xv(10),zdel(2),pmin(10),etot(2),etrmss(20),vconst(3),
     .  vcnsts(3)
      equivalence (etot(1),ehf),(etot(2),ehk)
C ... Parameters for iterations
      integer lsc,irs(5),nit,maxit
C ... Parameters for nonspherical density
      integer nqpp,oqpp,oqppo
C ... Parameters for spin dynamics
      double precision sdprm(6)
C ... Parameters for mixing.  Default parameters dmxprm:
C 1(I) mixing scheme; 2 beta; 3 wc; 4,5 wgt; 6(I)nsave 7(I) mmix;
C 8(I) nkill; 9 betv; 10 rmscst.  11-20 are outputs:
C 11 rmsdel 12 rms2 13 nmix 14 actual broy 15 actual beta 16-24 tj
C 25 1 if wt ne 0, 10 if wa ne 0, 11 if all nonzero
C 27..29: hold parms for static parms block regular mixing
C 30..32: hold parms for static parms block Euler angle mixing
C 33 : Lindhard screening parameter
C 34 : wa
      double precision dmxprm(34),dmxeu(34),rmsdel,rms2,betsv,rmscst,
     .  betv,qtol
      equivalence (dmxprm(9),betv),(dmxprm(10),rmscst),
     .  (dmxprm(11),rmsdel),(dmxprm(12),rms2),(dmxprm(15),betsv)
C ... Parameters for GF
#if GF
      logical a2bin
      integer moddos,nzp,npl
      integer ozp,owz,olgii,oogll,opgfsl,opgplp,ovshft,ovshfs
      double precision semsh(10)
C ... Parameters for non-equilibrium mode
      integer nzne,j
      logical lnoneq
#endif
      double precision vne,vrl
      integer npadl,npadr,nbasp
      integer ogrp2
C     for SX potential
      integer lrsig,lrsigl,ldham(16),lwsig
      double precision rsrnge
C..   new param for SX
      logical sxad
C.... Local parameters for LDA+U
      integer olldau,ovorb,odmatu,odmato,nlibu
      integer lmaxu,ng,ngi,oistab,og
      double precision umix,tolu

C ---------------------------- Setup ---------------------
C     call tcn('lmasa')
C ... Default values for mixing
      call dpzero(ehterm,6)
      call dpzero(dmxprm,34)
      call dpzero(vconst,3)
Cgetarg...info...           real(8) :: dmxprm(34) , real(8) :: smix%b 1
Cgetarg...info...           real(8) :: dmxprm(34) , real(8) :: smix%bv 1
Cgetarg...info...           real(8) :: dmxprm(34) , real(8) :: smix%w 3
Cgetarg...info...           real(8) :: dmxprm(34) , real(8) :: smix%wc 1
Cgetarg       call upack('mix b bv w wc',smix,dmxprm(2),dmxprm(9),dmxprm(4),
Cgetarg      .  dmxprm(3),0)
       
       dmxprm(2)=smix%b
       dmxprm(9)=smix%bv
       i_copy_size=size(smix%w) 
       call dcopy(i_copy_size,smix%w,1,dmxprm(4),1) 
       dmxprm(3)=smix%wc

Cgetarg       dmxprm(6) = igets('mix nsave',smix)
       dmxprm ( 6 ) = int(smix%nsave) 

Cgetarg       dmxprm(7) = igets('mix mmix',smix)
       dmxprm ( 7 ) = int(smix%mmix) 

Cgetarg...info...           integer :: nbas , integer(8) :: sctrl%nbas 1
Cgetarg...info...           integer :: nclass , integer(8) :: sctrl%nclass 1
Cgetarg...info...           integer :: nl , integer(8) :: sctrl%nl 1
Cgetarg...info...           integer :: nspec , integer(8) :: sctrl%nspec 1
Cgetarg...info...           integer :: nsp , integer(8) :: sctrl%nspin 1
Cgetarg       call upack('ctrl nbas nclass nl nspec nspin',sctrl,nbas,nclass,nl,
Cgetarg      .  nspec,nsp)
       
       nbas=sctrl%nbas
       nclass=sctrl%nclass
       nl=sctrl%nl
       nspec=sctrl%nspec
       nsp=sctrl%nspin

Cgetarg...info...           integer :: loptc , integer(8) :: sctrl%loptc 1
Cgetarg...info...           integer :: lasa , integer(8) :: sctrl%lasa 1
Cgetarg...info...           integer :: lsx , integer(8) :: sctrl%lsx 1
Cgetarg...info...           integer :: lncol , integer(8) :: sctrl%lncol 1
Cgetarg...info...           integer :: lham , integer(8) :: sctrl%lham 1
Cgetarg       call upack('ctrl loptc lasa lsx lncol lham',sctrl,loptc,lasa,lsx,
Cgetarg      .  lncol,lham)
       
       loptc=sctrl%loptc
       lasa=sctrl%lasa
       lsx=sctrl%lsx
       lncol=sctrl%lncol
       lham=sctrl%lham

Cgetarg       lpgf = igets('ctrl lpgf',sctrl)
       lpgf = int(sctrl%lpgf(1)) 

Cgetarg...info...           integer :: oeula , integer(8) :: sham%oeula 1
Cgetarg...info...           integer :: neul , integer(8) :: sham%neula 1
Cgetarg       call upack('ham oeula neula',sham,oeula,neul,0,0,0)
       
       oeula=sham%oeula
       neul=sham%neula

Cgetarg...info...           integer :: opp , integer(8) :: spot%opp 1
Cgetarg...info...           integer :: osop , integer(8) :: spot%osop 1
Cgetarg...info...           integer :: ogrrme , integer(8) :: spot%ogrrme 1
Cgetarg       call upack('pot opp osop ogrrme',spot,opp,osop,ogrrme,0,0)
       
       opp=spot%opp
       osop=spot%osop
       ogrrme=spot%ogrrme

Cgetarg...info...           integer :: sdmod , integer(8) :: sctrl%sdmod 1
Cgetarg...info...           real(8) :: sdprm(6) , real(8) :: sctrl%sdprm 5
Cgetarg...info...           integer :: maxit , integer(8) :: sctrl%maxit 1
Cgetarg...info...           real(8) :: zbak(2) , real(8) :: sctrl%zbak 2
Cgetarg       call upack('ctrl sdmod sdprm maxit zbak',sctrl,sdmod,sdprm,
Cgetarg      .  maxit,zbak,0)
       
       sdmod=sctrl%sdmod
       i_copy_size=size(sctrl%sdprm) 
       call dcopy(i_copy_size,sctrl%sdprm,1,sdprm,1) 
       maxit=sctrl%maxit
       i_copy_size=size(sctrl%zbak) 
       call dcopy(i_copy_size,sctrl%zbak,1,zbak,1) 

Cgetarg       lcgf = igets('ctrl lcgf',sctrl)
       lcgf = int(sctrl%lcgf) 

Cgetarg       iscr = mod(igets('ctrl lscr',sctrl),10)
       iscr = mod ( int(sctrl%lscr) , 10 ) 

Cgetarg       lrsig = igets('ham lsig',sham)
       lrsig = int(sham%lsig) 

Cgetarg...info...           integer :: oinitc , integer(8) :: sarray%ohave 1
Cgetarg...info...           integer :: oics , integer(8) :: sarray%oics 1
Cgetarg...info...           integer :: oclabl , integer(8) :: sarray%oclabl 1
Cgetarg...info...           integer :: onrcp , integer(8) :: sarray%onrcp 1
Cgetarg...info...           integer :: oipc , integer(8) :: sarray%oipc 1
Cgetarg       call upack('array ohave oics oclabl onrcp oipc',sarray,oinitc,
Cgetarg      .  oics,oclabl,onrcp,oipc)
       
       oinitc=sarray%ohave
       oics=sarray%oics
       oclabl=sarray%oclabl
       onrcp=sarray%onrcp
       oipc=sarray%oipc

Cgetarg...info...           integer :: npadl , integer(8) :: sarray%npadl 1
Cgetarg...info...           integer :: npadr , integer(8) :: sarray%npadr 1
Cgetarg...info...           integer :: nclasp , integer(8) :: sarray%nclasp 1
Cgetarg...info...           integer :: ormax , integer(8) :: sarray%ormax 1
Cgetarg...info...           integer :: ogroup , integer(8) :: sarray%ogroup 1
Cgetarg       call upack('array npadl npadr nclasp ormax ogroup',sarray,npadl,
Cgetarg      .  npadr,nclasp,ormax,ogroup)
       
       npadl=sarray%npadl
       npadr=sarray%npadr
       nclasp=sarray%nclasp
       ormax=sarray%ormax
       ogroup=sarray%ogroup

Cgetarg...info...           integer :: opnu , integer(8) :: spot%opnu 1
Cgetarg...info...           integer :: oqnu , integer(8) :: spot%oqnu 1
Cgetarg...info...           integer :: oqc , integer(8) :: spot%oqc 1
Cgetarg...info...           integer :: oqt , integer(8) :: spot%oqt 1
Cgetarg       call upack('pot opnu oqnu oqc oqt',spot,opnu,oqnu,oqc,oqt,0)
       
       opnu=spot%opnu
       oqnu=spot%oqnu
       oqc=spot%oqc
       oqt=spot%oqt

Cgetarg...info...           integer :: orhrmx , integer(8) :: spot%orhrmx 1
Cgetarg...info...           integer :: oves , integer(8) :: spot%oves 1
Cgetarg...info...           integer :: ovrmax , integer(8) :: spot%ovrmax 1
Cgetarg...info...           integer :: opmpol , integer(8) :: spot%opmpol 1
Cgetarg...info...           integer :: oqpp , integer(8) :: spot%oqpp 1
Cgetarg       call upack('pot orhrmx oves ovrmax opmpol oqpp',spot,orhrmx,oves,
Cgetarg      .  ovrmax,opmpol,oqpp)
       
       orhrmx=spot%orhrmx
       oves=spot%oves
       ovrmax=spot%ovrmax
       opmpol=spot%opmpol
       oqpp=spot%oqpp

Cgetarg...info...           integer :: ovintr , integer(8) :: spot%ovintr 1
Cgetarg...info...           integer :: orhos , integer(8) :: spot%orhos 1
Cgetarg...info...           integer :: oaamom , integer(8) :: spot%oaamom 1
Cgetarg...info...           integer :: nrhos , integer(8) :: spot%nrhos 1
Cgetarg       call upack('pot ovintr orhos oaamom nrhos',spot,
Cgetarg      .  ovintr,orhos,oaamom,nrhos,0)
       
       ovintr=spot%ovintr
       orhos=spot%orhos
       oaamom=spot%oaamom
       nrhos=spot%nrhos

      call sp2cls('spec idmod',sspec,w(oics),nl,1,nclasp,oidmod)
Cgetarg...info...           real(8) :: avw , real(8) :: slat%avw 1
Cgetarg       call upack1('lat avw',slat,avw)
       
       avw=slat%avw

Cgetarg       lnsph = isw(lgors('ctrl lasa,32',sctrl))
       lnsph = isw ( iand(32,int(sctrl%lasa)) .ne.0 ) 

Cgetarg       lfree = lgors('ctrl lasa,8',sctrl)
       lfree = iand(8,int(sctrl%lasa)) .ne.0 

      call supot(1,sctrl,slat,spot)
      vne = 0
      vrl = 0
      stdo = lgunit(1)
      procid = mpipid(1)
      master = 0

C ... Input from restart file
      if (cmdopt('--rs=',5,0,outs)) then
Cgetarg       irs(1) = igets('ctrl lrs,7',sctrl)
       irs ( 1 ) = iand(7,int(sctrl%lrs)) 

      if (irs(1) .gt. 0) then
        if (procid .eq. master) ifi = fopna('rsta',-1,0)
        call mpibc1(ifi,1,2,.false.,'lmasa','ifi')
        call asars(0,sctrl,ssite,sspec,slat,spot,sbz,w(opnu),w(oqnu),
     .    .false.,ifi)
        call clsprp(1,sctrl,sarray,sham,spot,sspec,slat,sbz,sstr,sstrn)
        if (procid .eq. master) call fclr('rsta',ifi)
C       call shoctl(sctrl,sspec,spot,sarray,0,stdo)
C       call rx('done')
      endif
      endif

#if PGF
C     for now
      iv(3) = 0
      iv(4) = 0
      if (cmdopt('-nofg=',6,0,outs)) then
        i = 6
        i = a2vec(outs,len(outs),i,2,', ',2,2,2,iv,iv(3))
      endif
Cgetarg...info...           integer :: iv(10) , integer(8) :: sarray%nofgl 1
Cgetarg...info...           integer :: iv(10) , integer(8) :: sarray%nofgr 1
Cgetarg       call pack2('array nofgl nofgr',sarray,iv(3),iv(4))
       
       sarray%nofgl=iv(3) 
       sarray%nofgr=iv(4) 


      if (lpgf .eq. 2) iscr = 0
#endif

      nbasp  = nbas + npadl + npadr
      nclspp = 2*nclasp-nclass
      nlspcp = nl*nsp*max(nclspp,nspec)
      nqpp   = (nl**2*(nl**2+1))/2
      lmfrce = bittst(lncol,16) .and. bittst(lncol,1)
Cgetarg       if (cmdopt('-noves',6,0,outs)) call lsets('ctrl lves',sctrl,T,1)
       if ( cmdopt ( '-noves' , 6 , 0 , outs ) ) then 
       
       call lsets_bitop_i8(sctrl%lves,1,T,1)
       endif 

Cgetarg       lves   = 2*igets('ctrl lves,1',sctrl)
       lves = 2 * iand(1,int(sctrl%lves)) 

      emad = 0
      trumad = 0
      seref = 0
      latok = 0
      call defrr(ovdif,-nclspp)
Cgetarg...info...           integer :: ovdif , integer(8) :: spot%ovdif 1
Cgetarg       call pack1('pot ovdif',spot,ovdif)
       
       spot%ovdif=ovdif 

C ... class-based arrays
      call sp2cls('spec z',sspec,w(oics),1,1,nclasp,oz)
      call sp2cls('spec lmxa',sspec,w(oics),1,1,nclasp,olmx)
C     call sp2cls('spec idxdn',sspec,w(oics),nl,1,nclasp,oidxdn)
      call sp2cls('spec grp2',sspec,w(oics),1,1,nclasp,ogrp2)
C     call redfi(ogrp2,nclasp)
C ... Other initialization
      call subasi(sctrl,sspec,sham)
      nband = nbas*nglob('mxorb')
Cgetarg       call defdr(oeband,nband*nsp*igets('bz nkp',sbz))
       call defdr ( oeband , nband * nsp * int(sbz%nkp) ) 


C ... Setup for charge mixing
      call parms0(dmxprm(30),dmxprm(31),dmxprm(32),1)
      if (lmfrce) then
        call dpzero(dmxeu,34)
        call dcopy(25,dmxprm,1,dmxeu,1)
      endif
      if (cmdopt('--mix=',6,0,outs)) then
        i = 6
        iv(4) = 1
        i = a2vec(outs,len(outs),i,2,', ',2,2,2,iv,iv(3))
        iv(4) = max(iv(4),1)
        call parmx0(iv(3),iv(4),0d0)
      endif

C ... Green's function specific setup
#if GF
Cgetarg...info...           real(8) :: semsh(10) , real(8) :: sbz%semsh 10
Cgetarg       call upack1('bz semsh',sbz,semsh)
       
       i_copy_size=size(sbz%semsh) 
       call dcopy(i_copy_size,sbz%semsh,1,semsh,1) 

      nzp = nint(semsh(1))
C ... setup for non-equilibrium mode
      call setne(sbz,sctrl,nzne,vne,lnoneq)
      if (lnoneq .and. (iscr .ne. 0 .or. lves .ne. 0) )
     . call rx ('lmasa not ready for iscr!=0 or lves!=0 in non-eq mode')

      i = 4
      if (cmdopt('-ef=',i,0,outs)) then
        if (.not. a2bin(outs,efermi,4,0,' ',i,-1)) call
     .    rxs2('LMASA: failed to parse "',outs(1:30),'%a"')
        call awrit2('%N Override file fermi level, use ef= %,6d, '//
     .    'delef= %,6d%N',' ',80,stdo,efermi,efermi(1)-semsh(4))
        i = mod(nint(semsh(2)),100)
        if (i .ne. 2) semsh(4) = efermi(1)
Cgetarg...info...           real(8) :: semsh(10) , real(8) :: sbz%semsh 10
Cgetarg         call pack1('bz semsh',sbz,semsh)
         
         i_copy_size=size(sbz%semsh) 
         call dcopy(i_copy_size,semsh,1,sbz%semsh,1) 

      endif
      efermi(1) = semsh(4)

      call defdc(ozp,nzp+nzne)
      call defdc(owz,nzp+nzne)
      call emesh(semsh,w(ozp),w(owz))
Cgetarg...info...           integer :: opgfsl , integer(8) :: sarray%opgfsl 1
Cgetarg...info...           integer :: opgplp , integer(8) :: sarray%opgplp 1
Cgetarg       call upack('array opgfsl opgplp',sarray,opgfsl,opgplp,0,0,0)
       
       opgfsl=sarray%opgfsl
       opgplp=sarray%opgplp

Cgetarg...info...           integer :: npl , integer(8) :: sctrl%npl 1
Cgetarg       call upack1('ctrl npl',sctrl,npl)
       
       npl=sctrl%npl

Cgetarg...info...           integer :: ovshft , integer(8) :: spot%ovshf 1
Cgetarg       call upack1('pot ovshf',spot,ovshft)
       
       ovshft=spot%ovshf


      i = 1+4
#if PGF
      i= 2+4
#endif
      ifi = fopn('VSHFT')
      call iovshf(nbas,i,'read file vshft: ef=%d  vconst=%d',
     .  efermi,xv,vconst,w(ovshft),ifi)
Cgetarg...info...           real(8) :: vconst(3) , real(8) :: spot%vconst 3
Cgetarg       call pack1('pot vconst',spot,vconst)
       
       i_copy_size=size(spot%vconst) 
       call dcopy(i_copy_size,vconst,1,spot%vconst,1) 

      call fclr('VSHFT',-1)
      call defdr(ovshfs, 8+nbasp)
#if PGF
      vrl = vne + vconst(3)-vconst(2)
#endif
#else
#endif

C ------------------- Generate ASA potential ------------------
      makepp = mod(lasa,4) .ne. 0 .and. getdig(sdmod,3,10) .eq. 0
      nwmoms = .false.
      nit = 0
   10 continue

C --- Madelung energy, potential, number of valence electrons ---
      call pshpr(0)
      call defdr(odq,nclasp)
      call getq(nsp,nl,w(olmx),nclasp,w(oz),w(opnu),w(oqnu),w(oics),
     .  sspec,w(oqc),w(oqt),w(odq))
      call togprt
      call getzv(nclasp,w(onrcp),w(oz),w(oqc),sbz,sctrl,zval)
      call togprt
      call rlse(odq)
C ... undo shift that would be added to pp's when they are made
C     in case they are not made
      call shftpp(nclasp,nl*nsp,w(opp),w(oves),w(oves),T,F)
      call asamad(sctrl,spot,sarray,slat,sspec,lves+100,
     .  w(opnu),w(oqnu),vrl,w(oves),emad,trumad,vmtz)
C ... add shift for v as have now
      call shftpp(nclasp,nl*nsp,w(opp),w(oves),w(oves),F,T)
      call poppr

C --- Sphere program.  Make potential parameters ---
      imake = 0
      if (makepp) imake = 3
      if (bitand(lasa,3) .ge. 2) imake = 2
      if (imake .eq. 3 .and. lfree) imake = 1
      if (bitand(lasa,3) .eq. 3)
     .  call rx('lmasa: not ready for BEGMOM=3')
C     Temporarily set lscr when making vintra only selected iterations
Cgetarg       iscsav = igets('ctrl lscr',sctrl)
       iscsav = int(sctrl%lscr) 

      if (mod(iscsav,100) .ge. 20) then
Cgetarg         if (mod(nit,mod(iscsav,100)/10) .ne. 0)
Cgetarg      .    call pack1('ctrl lscr',sctrl,0)
         if ( mod ( nit , mod ( iscsav , 100 ) /10 ) .ne. 0 ) then 
         
         sctrl%lscr=0 
         endif 

      endif
      call asvsph(sctrl,slat,sarray,sspec,sham,spot,vrl,imake,
     .  ehterm,latok)

Cgetarg...info...           real(8) :: etrmss(20) , real(8) :: sham%eterms 20
Cgetarg       call upack1('ham eterms',sham,etrmss)
       
       i_copy_size=size(sham%eterms) 
       call dcopy(i_copy_size,sham%eterms,1,etrmss,1) 

Cgetarg       amgm = dgets('ham eterms:15',sham)
       amgm = sham%eterms(15) 

Cgetarg       sevat = dgets('ham eterms:16',sham)
       sevat = sham%eterms(16) 

C     Reset lscr
Cgetarg...info...           integer :: iscsav , integer(8) :: sctrl%lscr 1
Cgetarg       call pack1('ctrl lscr',sctrl,iscsav)
       
       sctrl%lscr=iscsav 


C ... Update second-padded pnu,qnu, in case they changed
#if PGF
      call clsprp(1,sctrl,sarray,sham,spot,sspec,slat,sbz,sstr,sstrn)
#endif

C ... Save convergence data in save file
      if (nit .gt. 0 .and. procid .eq. master) then
        call poseof(fopn('SV'))
        do  57  i = 1, 3
          if (i .eq. 1 .and. iprint() .lt. 10) goto 57
          ifi = lgunit(i)
          if (i .eq. 3) ifi = fopn('SV')
          call iosv(-ifi,nit,dmxprm,ehk,amgm,.true.)
   57   continue
        call fclose(fopn('SV'))
      endif

C --- Re-entry point for non-self-consistent calculations ---
   58 continue

C ... Output to restart file (eventually only for nit>0)
      if (cmdopt('--rs=',5,0,outs)) then
Cgetarg         irs(2) = igets('ctrl lrs,8+16',sctrl)/8
         irs ( 2 ) = iand(8+16,int(sctrl%lrs)) /8 

        if (irs(2) .gt. 0) then
          if (procid .eq. master) ifi = fopna('rsta',-1,0)
          call mpibc1(ifi,1,2,.false.,'lmasa','ifi')
          call asars(0,sctrl,ssite,sspec,slat,spot,sbz,
     .      w(opnu),w(oqnu),.false.,-ifi)
          if (procid .eq. master) call fclr('rsta',ifi)
        endif
      endif

C --- Print out summary of this iteration, check for convergence ---
      lsc = 3
      if (nit .gt. 0) then
        xv(3) = ehf
        xv(4) = ehk
Cgetarg         qtol = dgets('ctrl tol',sctrl)
         qtol = sctrl%tol(1) 

Cgetarg         etol = dgets('ctrl tol:3',sctrl)
         etol = sctrl%tol(3) 

        xv(1) = rmsdel
C       Independent mixing of Euler angles: combine rms dq, deuler
        if (getdig(sdmod,1,10).eq.1) xv(1)=sqrt(rmsdel**2+dmxprm(32)**2)
        if (procid .eq. master) then
Cgetarg           call nwit(igets('ctrl nvario',sctrl),nit,maxit,.false.,1,etol,
Cgetarg      .      qtol,xv,'cxhi',amgm,xv(3),lsc)
           call nwit ( int(sctrl%nvario) , nit , maxit , .false. , 1 , etol 
     .     , qtol , xv , 'cxhi' , amgm , xv ( 3 ) , lsc ) 

        endif
        call mpibc1(lsc,1,2,.false.,'lmasa','lsc')
      elseif (iprint() .ge. 10 .and. makepp) then
C       Extract calculated energy parameters
Cgetarg...info...           real(8) :: ehk0 , real(8) :: sham%ehk 1
Cgetarg...info...           real(8) :: thrpv , real(8) :: sham%thrpv 1
Cgetarg...info...           real(8) :: seref , real(8) :: sham%seref 1
Cgetarg         call upack('ham ehk thrpv seref',sham,ehk0,thrpv,seref,0,0)
         
         ehk0=sham%ehk
         thrpv=sham%thrpv
         seref=sham%seref

        do  55  i = 1, 2
          call awrit6('%x '//prgnam//'%a: it %i of %i  '//
     .      'ehk0=%1,6d  pv=%1;4d  mmom=%1;4d'//'  seref=%1;6d',outs,
     .      80,lgunit(i),nit,maxit,ehk0,thrpv/3,amgm,seref)
   55   continue
      endif
      if (iprint() .gt. 30) call cpudel(stdo,'...   Time this iter:',xv)

C ... Invoke shell command if supplied
      outs = ' '
      if (nit .gt. 0 .and. cmdopt('--sh=',5,0,outs)) then
        call awrit0(' LM: invoke sh="'//outs(6:len(outs))//'%a"',
     .    ' ',len(outs),stdo)
        call fsystm(outs(6:len(outs)),i)
        call awrit1(' LM: shell returned value %i',' ',80,stdo,i)
      endif

C ... When quit is specified or insufficient information to continue
Cgetarg       if (igets('ctrl quit',sctrl).eq.2 .or. getdig(latok,0,10) .eq. 0
Cgetarg      .    .or. bittst(lasa,8)) then
       if ( int(sctrl%quit) .eq.2 .or. getdig ( latok , 0 , 10 ) .eq. 
     . 0 .or. bittst ( lasa , 8 ) ) then 

        call info0(0,0,0,' '//prgnam//
     .    '%a:  Q=ATOM encountered or missing input')
        goto 99
      endif
C ... Spin statics or dynamics: charge self-consistency not a criterion
      if (lsc .eq. 0 .and. lmfrce .and. getdig(sdmod,0,10).gt.1) lsc=3
C ... Interactive query for number of iterations
      call ftflsh(stdo)
      if (lsc .eq. 0) then
        if (procid .eq. master) write(stdo,302) rms2
  302   format(/' Jolly good show !  You converged to rms DQ=',f10.6)
        goto 99
      endif
      call query('max it',2,maxit)
      if (nit .ge. maxit) goto 99
      nit = nit+1
C ... If subsequent iterations have moments in hand
      makepp = makepp .or. nwmoms
      makepp = makepp .and. getdig(sdmod,3,10) .eq. 0

C ------------------------- Band pass --------------------------
C ... Keep a copy of input P,Q and related parameters
      call defdr(opold,nlspcp)
      call defdr(oqold,3*nlspcp)
      call defdr(ovold,nclspp)
      call defdr(oeulo,3*neul*nbasp)
      call dcopy(nlspcp,w(opnu),1,w(opold),1)
      call dcopy(3*nlspcp,w(oqnu),1,w(oqold),1)
      call dcopy(nclspp,w(oves),1,w(ovold),1)
      if (lnsph.ne.0) then
        call defcc(oqppo,nqpp*4*nsp*nbas)
        call dcopy(2*nqpp*4*nsp*nbas,w(oqpp),1,w(oqppo),1)
      endif

      call suham(sctrl,slat,sspec,ssite,sarray,sham,spot,sstrn,sbz)

C ... Quit if --quit=ham given
Cgetarg       if (igets('ctrl quit',sctrl) .eq. 8) then
       if ( int(sctrl%quit) .eq. 8 ) then 

        call rx0('quit = ham')
      endif

C ... Read and store self-energy addition to LDA potential
Cgetarg...info...           integer :: ldham(16) , integer(8) :: sham%ldham 16
Cgetarg       call upack1('ham ldham',sham,ldham)
       
       i_copy_size=size(sham%ldham) 
       call i8icopy(i_copy_size,sham%ldham,1,ldham,1) 

      lrsigl = lrsig
      if (lrsigl .ne. 0 .and. fxst('sigm') .ne. 1) then
        call info0(1,1,0,' lmasa (warning): '//
     .    'no sigm file found ... LDA calculation only')
Cgetarg         call pack1('ham lsig',sham,0)
         
         sham%lsig=0 

        lrsigl = 0
      endif
      sxad = F
      if (mod(lrsigl,10) .ne. 0) then
C       Real-space range
Cgetarg         rsrnge = dgets('ham rsrnge',sham)
         rsrnge = sham%rsrnge 

        ifi = fopna('sigm',-1,4)
        call rdsigm(1000+lrsigl,nbas,nsp,ldham(1),slat,sham,
     .    sbz,ifi,rsrnge,lwsig)
        call fclose(ifi)
        sxad = T
      endif

C ... LDA+U initialization
      call defi(olldau, -nbasp)
      call defrr(ovorb,1)
      call defcc(odmatu,1)
      call defcc(odmato,1)
      
C     Check for LDA+U ... return nlibu > 0 if any U blocks.
      call suldau(nbasp,sspec,ssite,nlibu,lmaxu,w(olldau))
Cgetarg...info...           integer :: nlibu , integer(8) :: sham%nlibu 1
Cgetarg...info...           integer :: lmaxu , integer(8) :: sham%lmaxu 1
Cgetarg       call pack5('ham nlibu lmaxu',sham,nlibu,lmaxu,0,0,0)
       
       sham%nlibu=nlibu 
       sham%lmaxu=lmaxu 

        
C ... Read LDA+U Hamiltonian
      if (nlibu .gt. 0) then
        call rlse(ovorb)
        i = nsp*nlibu*(lmaxu*2+1)**2
        call defcc(ovorb,-i)
        call defcc(odmatu,-i)
        call defcc(odmato,-i)
C       need group info to symmetrize site density matrix
Cgetarg...info...           integer :: ng , integer(8) :: slat%nsgrp 1
Cgetarg...info...           integer :: oistab , integer(8) :: slat%oistab 1
Cgetarg...info...           integer :: og , integer(8) :: slat%osymgr 1
Cgetarg         call upack('lat nsgrp oistab osymgr',slat,ng,oistab,og,0,0)
         
         ng=slat%nsgrp
         oistab=slat%oistab
         og=slat%osymgr

C       layer GF code doesn't have istab for padding layers.
        ngi = ng
        if (lpgf .ne. 0) then
          ngi = 0
        endif
Cgetarg...info...           real(8) :: umix , real(8) :: smix%umix 1
Cgetarg...info...           real(8) :: tolu , real(8) :: smix%tolu 1
Cgetarg         call upack('mix umix tolu',smix,umix,tolu,0,0,0)
         
         umix=smix%umix
         tolu=smix%tolu

C       initialize density matrix for LDA+U

        i = 0
        if (bittst(lham,256)) i = 1
        call sudmtu(nbasp,nsp,nlibu,lmaxu,ssite,sspec,i,w(olldau),
     .    ngi,w(og),w(oistab),w(odmatu),w(ovorb))
          
C       Hang on to previous site density matrix for this iteration
        i = nsp*nlibu*(lmaxu*2+1)**2
        call dcopy(2*i,w(odmatu),1,w(odmato),1)
        call dpzero(w(odmatu),2*i)

      endif

C --- Green's function approaches ---
#if GF
      if (lpgf .ne. 0) then
#if PGF
        call defi(oogll,npl+4)
        call defi(olgii,npl+4)
        call iinit(w(olgii),npl+4)

CC       Printout vshft
C        call iozshf(nbasp,1,w(ovshft),w(oipc),w(ogrp2),-stdo)
CC       Replicate vshft->vshfs; distribute averages for pgfasa
CC       Now done in pgfasa
CC       call vshfav(11,npl,w(opgplp),w(ovshfs),w(ovshft))

        call pgfasa(sctrl,slat,sarray,sspec,ssite,sbz,sstr,sham,spot,
     .    sstrn,w(olldau),w(ovorb),w(odmatu),
     .    vconst,w(ovshft),w(ozp),w(owz),w(opgfsl),w(opgplp),
     .    efermi,moddos,sumev,w(oqnu),w(orhos),amag,w(oaamom),w(olgii),
     .    w(oogll))
        if (mod(mod(moddos,10),2) .ne. 1) goto 99
        nevmx = 1
C       call shoctl(sctrl,sspec,spot,sarray,0,stdo)

C       Add vshft(ib) to vdif to make etot when Ves ne Ves[n]
        if (lves .eq. 2)
     .    call vsh2es(1,nbasp,w(oipc),w(onrcp),w(ovshft),w(ovdif))
C       Update vshft file
        if (lpgf .le. 2) then
          ifi = fopn('VSHFT')
          call iovshf(nbas,6,' ',efermi,efermi,vconst,w(ovshft),-ifi)
          call fclr('VSHFT',-1)
        endif

#endif
#if CGF
      elseif (lcgf .ne. 0) then

C       Temporarily set lscr when making psta only selected iterations
Cgetarg         iscsav = igets('ctrl lscr',sctrl)
         iscsav = int(sctrl%lscr) 

        if (mod(iscsav,1000) .ge. 200) then
Cgetarg           if (mod(nit,mod(iscsav,1000)/100) .ne. 0)
Cgetarg      .      call pack1('ctrl lscr',sctrl,0)
           if ( mod ( nit , mod ( iscsav , 1000 ) /100 ) .ne. 0 ) then 
           
           sctrl%lscr=0 
           endif 

        endif
        call dpcopy(vconst,vcnsts,1,3,1d0)
        call gfasa(sctrl,slat,sarray,sspec,ssite,sbz,sham,spot,sstrn,
     .    w(olldau),w(ovorb),w(odmatu),
     .    vconst,w(ovshft),w(ozp),w(owz),w(opgplp),efermi,moddos,sumev,
     .    ehterm,w(oqnu),w(orhos),amag,w(oaamom),sxad)
C       Reset lscr
Cgetarg...info...           integer :: iscsav , integer(8) :: sctrl%lscr 1
Cgetarg         call pack1('ctrl lscr',sctrl,iscsav)
         
         sctrl%lscr=iscsav 


        if (mod(mod(moddos,10),2) .ne. 1) goto 99
        nevmx = 1
C       call shoctl(sctrl,sspec,spot,sarray,0,stdo)

C       Add vshft(ib) to vdif to make etot when Ves ne Ves[n]
        if (lves .eq. 2)
     .    call vsh2es(1,nbasp,w(oipc),w(onrcp),w(ovshft),w(ovdif))

C       Update vshft file
        ifi = fopn('VSHFT')
        call iovshf(nbas,5,' ',efermi,efermi,vconst,w(ovshft),-ifi)
        call fclr('VSHFT',-1)


C  ... Check convergence of dmatu and update it and vorb if necessary
        if (nlibu .gt. 0 .and. maxit .gt. 0) then        
        i = 0
        if (bittst(lham,256)) i = 1
          call chkdmu(nbas,nsp,nlibu,lmaxu,ssite,sspec,sham,i,w(odmatu),
     .      w(odmato),w(ovorb),tolu,umix,w(olldau),ng,w(og),w(oistab))
        endif

#endif
      else
C        if (mordrn .eq. EMCLUS) then
C          call rx('emc not ready')
C          call emc2C(s_ordn,nl,nlo,nsp,nbas,w(olmx),nclass,w(oipc),
C     .      w(oeula),switch,w(opp),vmtz,elin,wsr,
C     .      efmax,nevmx,z,w(oqc),w(oeband),nband,
C     .      norder,width,range,npts,drange,
C     .      avw,zval,plat,w(obas),w(ogroup),efermi,sumev,w(orhos))
C        endif
        call rx('no technique specified to generate density')
      endif

#else
C --- Energy bands by direct diagonalization ---
C     Suppress ccor if generating evecs for response function
Cgetarg...info...           NG:: lasa-bitand(lasa,4) , integer(8) :: sctrl%lasa 1
Cgetarg       if (mod(lsx,2) .eq. 1 .or. mod(iscr,2) .eq. 1)
Cgetarg      .  call pack1('ctrl lasa',sctrl,lasa-bitand(lasa,4))
       if ( mod ( lsx , 2 ) .eq. 1 .or. mod ( iscr , 2 ) .eq. 1 ) then 
       
       sctrl%lasa=lasa-bitand(lasa,4) 
       endif 

      call bndasa(sctrl,slat,sspec,ssite,sarray,sbz,sham,spot,sstrn,
     .  w(ovorb),w(odmatu),
     .  efermi,w(oeband),nband,nevmx,w(oqnu),sumev,w(orhos),amag,
     .  w(oaamom))

C ... Check convergence of dmatu and update it and vorb if necessary
      if (nlibu .gt. 0 .and. maxit .gt. 0 .and. nevmx .gt. 0) then        
        i = 0
        if (bittst(lham,256)) i = 1
        call chkdmu(nbas,nsp,nlibu,lmaxu,ssite,sspec,sham,i,w(odmatu),
     .    w(odmato),w(ovorb),tolu,umix,w(olldau),ng,w(og),w(oistab))
      endif

Cgetarg...info...           integer :: lasa , integer(8) :: sctrl%lasa 1
Cgetarg       call pack1('ctrl lasa',sctrl,lasa)
       
       sctrl%lasa=lasa 


C --- Rucker's screened exchange ---
#if SX
      if (mod(lsx,2) .eq. 1 .or. mod(iscr,2) .eq. 1) then
        aintra = T
        zdel(1) = 0
        zdel(2) = 0
        call upacks('strn sxopt',i1,i2)
        sxopts = ' '
        if (i2 .ge. i1) sxopts = sstrn(i1:i2)
        if (mod(lsx,2) .eq. 0) sxopts = 'pstat'
        if (cmdopt('-novintr',4,0,outs))
     .    call dpzero(w(ovintr),nclasp*nl*nl*nsp*nsp)
        call asasx(sctrl,sspec,ssite,sarray,slat,sham,spot,sbz,sstrn,
     .    sxopts,aintra,nl,nsp,efermi,w(oeband),nband,zdel,w(ovintr))
C        call rx0('finished calling asasx ('//sxopts//'%a)')
        goto 99
      endif
#endif
c###### (SX branch)

      if (nevmx.gt.0 .and. procid .eq. master) then
        call shoctl(sctrl,sspec,spot,sarray,0,fopn('LOG'))
      endif

#if STONER
Cgetarg       if (lgors('ctrl lstonr',sctrl)) then
       if ( iand(0,int(sctrl%lstonr(1))) .ne.0 ) then 

        call defdr(onbar,mnpts)
        call defdr(oewk,mnpts)
        call defdr(omwk,mnpts)
        call defdr(oamom,-nbas)
        call defdr(oemag,-nbas)
        call rx('fix clabl for call to stoner')
        call stoner(nl,nbas,nclass,clabl,w(oipc),w(oidxdn),efermi,
     .    drange,iabs(npts),w(ozos),w(oindex),w(ostni),w(oammx),
     .    mnpts,switch(44),w(onbar),w(oewk),w(omwk),w(oamom),
     .    w(oemag))
      endif
#endif

#endif
c######  (hamiltonian or GF branches)

C --- Harris and HK energies if terms are available ---
C ... OLD STYLE
C      ehterm(5) = dgets('ham eterms:17',sham)
C      ehterm(6) = dgets('ham eterms:18',sham)
C      call cwrite(' *** OLD',0,7,0)
C      xv(1) = 0
C      if (getdig(latok,1,10) .eq. 0) then
C        ehf = 0
C      else
C        if (lves .eq. 2 .and. nevmx .gt. 0) call ehcor(nclasp,w(onrcp),
C     .    w(oclabl),w(ovdif),nl,nsp,w(oqold),w(oqnu),xv(1))
C        xv(2) = sumev-ehterm(2)-ehterm(3)-ehterm(5)
C        ehf = xv(2) + xv(1)*0 + ehterm(1) + ehterm(4)
C        do  34  i = 1, 2
C          if (xv(1) .eq. 0) call awrit3(' '//prgnam//
C     .      '%a: ehf=%1,7;7d  sumev=%1,7;7d  delsev=%1,7;7d',outs,80,
C     .      lgunit(i),ehf,sumev,xv(2))
C          if (xv(1) .ne. 0) call awrit4(' '//prgnam//
C     .      '%a: ehf=%1,7;7d  sumev=%1,7;7d  delsev=%1,7;7d  ehcor='//
C     .      '%d (not inc)',outs,80,lgunit(i),ehf,sumev,xv(2),xv(1))
C   34   continue
C      endif

C ... HF energy
      ehf = 0
      if (getdig(latok,1,10) .ne. 0) call asetot(1,sham,sumev,ehf)
C ... HK energy
      ehk = 0
      if (nevmx .gt. 0) then
        call pshpr(max(iprt(1)-100,0))
        call pshpr(max(iprt(1)-20,0))
        call asvsph(sctrl,slat,sarray,sspec,sham,spot,vrl,4,
     .    ehterm,latok)
        call poppr
        call poppr
        if (getdig(latok,1,10) .ne. 0) call asetot(2,sham,sumev,ehk)
      endif

      if (ehf .ne. 0) then
        do  i = 1, 2
          if (iprint() .ge. 10 .or. i .eq. 2) then
            call awrit6('%N '//prgnam//'%a: '//
     .        'ehf=%1,7;7d  %?#n#ehk=%1,7;7d  #%j#sumev=%1,7;7d'//
     .        '%?#n#  delsev=%1,7;7d',
     .        outs,80,lgunit(i),
     .        ehf,isw(ehk.ne.0),ehk,sumev,isw(sevat.ne.0),sumev-sevat)
          endif
        enddo
      endif

C --- Early program exit ---
Cgetarg       if (igets('ctrl quit',sctrl) .eq. 4 .or. nevmx .le. 0) then
       if ( int(sctrl%quit) .eq. 4 .or. nevmx .le. 0 ) then 

Cgetarg         i = igets('ctrl nvario',sctrl)
         i = int(sctrl%nvario) 

        if (procid .eq. master) then
          call nwitsv(1+2,i,'h67',nsp,amgm,etot)
        endif

C   ... Invoke shell command if supplied
        outs = ' '
        if (nit .gt. 0 .and. cmdopt('--sh=',5,0,outs)) then
          call awrit0(' LM: invoke sh="'//outs(6:len(outs))//'%a"',
     .      ' ',len(outs),stdo)
          call fsystm(outs(6:len(outs)),i)
          call awrit1(' LM: shell returned value %i',' ',80,stdo,i)
        endif

        call rx0(prgnam//': quit after bands')
      endif

C --- Magnetic torque ---
#if NC
      if (lmfrce) then
        call dcopy(3*neul*nbasp,w(oeula),1,w(oeulo),1)
        call defrr(ofrc, 3*nbas+3)
        call magtrq(nbasp,nl,nclasp,w(oipc),sdmod,sdprm,ssite,sspec,
     .    w(oclabl),w(opp),w(orhos),nrhos,ehf,w(oeula),neul,w(ofrc),
     .    w(oaamom))
        if (mod(sdmod,10) .eq. 3) then
          call rx('lmasa not ready for sdmod=3')
CC     ... for now, copy eula to work array with one eula/atom
C          stop 'nl->neula'
C          call defrr(owk2, 2*nbas+3)
C          call dpscop(w(oeula),w(owk2),nbasp,nbasp*nl+1,nbas+1,1d0)
C          call dpscop(w(oeula),w(owk2),nbasp,1,1,1d0)
C          call defrr(owk, 3*nbas+3)
C          print *, 'put irmmd in bsi,bswk'
C          call u_bsi(s_sdyn,i,j,iv,xv,xx1,xx2,obswk,k,-1)
CC     ... pull out second number from verbosity stack
C          call togprt
C          j = iprint()
C          call poppr
C          ifi = fopn('SAVE')
C          call poseof(ifi)
C          call mm_dyn(nbas,xsi,w(owk2),w,w(owk),w,w,nstep,irmmd,w,0,
C     .      w(obswk),w(ofrc),amag,w(oaamom),ehf,s_sdyn,nvarms,ifi)
C          call fclose(ifi)
C          call pshpr(j)
C          call togprt
C          do  36  j = 1, nl
C          call dpscop(w(owk2),w(oeula),nbasp,1,nbasp*(j-1)+1,1d0)
C   36     call dpscop(w(owk2),w(oeula),nbasp,nbasp+1,nbasp*(nl+j-1)+1,
C     .      1d0)
        endif
        call rlse(ofrc)
      endif
#endif

C --- Estimate self-consistent moments from dielectric response ---
      call asalsq(iscr,sctrl,slat,sspec,sarray,sham,sbz,spot,vrl,
     .  w(oqold),w(oqnu))

C ... Update changes in vconst
Cgetarg...info...           real(8) :: vconst(3) , real(8) :: spot%vconst 3
Cgetarg       call pack1('pot vconst',spot,vconst)
       
       i_copy_size=size(spot%vconst) 
       call dcopy(i_copy_size,vconst,1,spot%vconst,1) 


C --- Shift moments to the center of gravity of band ---
      makepp = getdig(sdmod,3,10) .eq. 0
      if (makepp) then
        call mixpqc(nclasp,w(onrcp),nl,nsp,w(ogrp2),w(opnu),w(oqnu))
Cgetarg...info...           real(8) :: pmin(10) , real(8) :: sham%pmin 10
Cgetarg         call upack1('ham pmin',sham,pmin)
         
         i_copy_size=size(sham%pmin) 
         call dcopy(i_copy_size,sham%pmin,1,pmin,1) 

        call shftpq(nclasp,w(onrcp),nsp,nl,w(olmx),w(ormax),avw,w(opp),
     .    w(oqnu),w(oidmod),.false.,pmin,w(opnu),w(oqnu),xv)
      endif

#if LMCNST
C --- Make output ves ---
      call asamad(sctrl,spot,sarray,slat,sspec,0,w(opnu),w(oqnu),
     .          vrl,w(oves),emad,trumad,vmtz)
C --- Map ves into vtil ---
      call defdr(ovtil,nbas)
      call defdr(ovotil,nbas)
      call defdr(omad2,nbas**2)
      call defdr(oumad,nbas**2)
      call defdr(oevmad,nbas)
      call rotmad(nbas,nclasp,w(oipc),wsr,w(omad),w(ovold),w(oves),
     .  w(onrcp),emad0,modcst,w(omad2),w(ogroup),
     .  w(oevmad),w(oumad),w(ovotil),w(ovtil),nvmix)
C --- Mix vtil; back transform to ves ---
      call vmix(nclasp,nl,nsp,nbas,w(oves),w(ovold),w(opp),
     .  w(oiclas),w(onrcp),w(ovtil),w(ovotil),w(oumad),w(oevmad),
     .  modcst,w(ogroup),wsr,w(omad),nvmix,switch(4))
#endif

C --- Mix moments and/or Euler angles ---
      nwmoms = .false.
      if (makepp) then
        dmxprm(9) = betv
C   ... Get mixing string; set up mixing constraint for pqmix
        call upacks('strn mix',i1,i2)
C   ... Save qnu for independent potential mixing
Cgetarg         i = igets('mix lxpot',smix)
         i = int(smix%lxpot) 

        opnus = opnu
        oqnus = oqnu
        if (i .eq. 2) then
          call defdr(opnus,nlspcp)
          call defdr(oqnus,3*nlspcp)
          call dcopy(nlspcp,w(opnu),1,w(opnus),1)
          call dcopy(3*nlspcp,w(oqnu),1,w(oqnus),1)
        endif
C   ... Extra degrees of freedom
        call defi(omxcst, nclasp+1)
        i = 3*nl*nl*nbas
        if (lnsph.ne.0) i = i + nqpp*4*nsp*nbas
        call defrr(oxold, i)
        call defrr(oxnew, i)
        sw = lmfrce .and. getdig(sdmod,1,10).eq.0 .and. neul .gt. 0
        call pvpqm1(0,sspec,nclass,nclasp,nsp,nbas,lpgf,F,lnsph.ne.0,sw,
     .    neul,w(oics),w(oipc),w(omxcst),nqpp,w(oqppo),w(oqpp),w,w,
     .    w(oeulo),w(oeula),vcnsts,vconst,i,w(oxold),w(oxnew))
        dmxprm(34) = dmxprm(4)
        call pqmix(nclasp,nl,w(olmx),nsp,i,nit,sstrn(i1:i2),dmxprm,
     .    w(omxcst),w(opold),w(oqold),w(oxold),w(opnu),w(oqnu),w(oxnew))
        call pvpqm1(1,sspec,nclass,nclasp,nsp,nbas,lpgf,F,lnsph.ne.0,sw,
     .    neul,w(oics),w(oipc),w(omxcst),nqpp,w(oqppo),w(oqpp),w,w,
     .    w(oeulo),w(oeula),vcnsts,vconst,i,w(oxold),w(oxnew))
        call rlse(omxcst)
        betv = dmxprm(9)
C   ... Independent potential mixing
        if (lves .eq. 2) then
C     ... ves [mixed rho or output rho], depending on mix->lxpot
C         NB: Not needed if screened ves available.
C         But this makes ves[screened output rho, so ok.
C         if (mod(iscr/2,2) .eq. 0) then
          call pshpr(iprint()-20)
          call asamad(sctrl,spot,sarray,slat,sspec,0,
     .      w(opnus),w(oqnus),vrl,w(oves),emad,trumad,vmtz)
          call poppr
C         endif
          call vmix2(nclasp,w(oclabl),betv,w(ovold),w(oves))
Cgetarg           if (igets('mix lxpot',smix) .eq. 2) call rlse(opnus)
           if ( int(smix%lxpot) .eq. 2 ) call rlse ( opnus ) 

        endif
        if (procid .eq. master) then
          call shoctl(sctrl,sspec,spot,sarray,1,fopn('LOG'))
        endif
        if (mod(nint(dmxprm(25)),10) .eq. 1) nwmoms = .true.

C     Potential is frozen: keep starting P,Q, d.c. terms
      else
C       call shoctl(sctrl,sspec,spot,sarray,0,stdo)
        call dcopy(nlspcp,w(opold),1,w(opnu),1)
        call dcopy(3*nlspcp,w(oqold),1,w(oqnu),1)
C       call shoctl(sctrl,sspec,spot,sarray,0,stdo)
Cgetarg...info...           real(8) :: etrmss(20) , real(8) :: sham%eterms 20
Cgetarg         call pack1('ham eterms',sham,etrmss)
         
         i_copy_size=size(sham%eterms) 
         call dcopy(i_copy_size,etrmss,1,sham%eterms,1) 

      endif

C ... Save mixed qpp array
      if (lnsph .ne. 0) call ioqpp(T,sctrl,spot)

C ... Independent mixing of Euler angles (moms into scratch)
      if (lmfrce .and. getdig(sdmod,1,10).eq.1 .and. neul .gt. 0) then
        call upacks('strn amix',i1,i2)
        if (i2 .le. i1) then
          outs = 'A0,b=1,w=0,0,wa=1,fn=ma'
        else
          outs = sstrn(i1:i2)
        endif
        call info0(31,1,0,' Independently mix Euler angles')
        call defdr(owk,nlspcp)
        call defdr(owk2,3*nlspcp)
        call dcopy(nlspcp,w(opnu),1,w(owk),1)
        call dcopy(3*nlspcp,w(oqnu),1,w(owk2),1)
C   ... Pull out regular mixing variables, poke in Euler-specific
        call parms0(dmxprm(27),dmxprm(28),dmxprm(29),1)
        call parms0(dmxprm(30),dmxprm(31),dmxprm(32),-1)
        call defi(omxcst, nclasp+1)
        call defrr(oxold, 3*nl*nl*nbas)
        call defrr(oxnew, 3*nl*nl*nbas)
        call pvpqm1(0,sspec,nclass,nclasp,nsp,nbas,0,F,F,T,neul,w(oics),
     .    w(oipc),w(omxcst),nqpp,w,w,w,w,w(oeulo),w(oeula),vcnsts,
     .    vconst,i,w(oxold),w(oxnew))
        dmxeu(4) = 0
        dmxeu(5) = 0
        dmxeu(34) = 1
        call pqmix(nclasp,nl,w(olmx),nsp,i,nit,outs,dmxeu,
     .    0,w(opnu),w(oqnu),w(oxold),w(owk),w(owk2),w(oxnew))
        call pvpqm1(1,sspec,nclass,nclasp,nsp,nbas,0,F,F,T,neul,w(oics),
     .    w(oipc),w(omxcst),nqpp,w,w,w,w,w(oeulo),w(oeula),vcnsts,
     .    vconst,i,w(oxold),w(oxnew))
        call parms0(dmxprm(30),dmxprm(31),dmxprm(32),1)
        call parms0(dmxprm(27),dmxprm(28),dmxprm(29),-1)
        call rlse(owk)
      endif

C ... Write updated Euler angles to disk
      if (bittst(lncol,1) .and. getdig(sdmod,0,10).ne.3) then
        if (procid .eq. master) then
        ifi = fopn('EULA')
        rewind ifi
        call ioeula(nbasp,nl,w(oeula),neul,0d0,-ifi)
        call fclose(ifi)
        endif
      endif
      call rlse(opold)
C ... Skip over self-consistency when Euler angles are l-dependent
      if (.not. nwmoms) goto 58
      goto 10

   99 continue
C     call tcx('lmasa')

Cgetarg       end
       end subroutine lmasa 


C      subroutine snot(spot)
C      implicit none
C      double precision spot(1),vshft(-7:19),ves(9)
C      integer w(1)
C      common /w/ w
C      integer ovshft
C      call upack1('pot ovshf',spot,ovshft)
C      call dcopy(26,w(ovshft),1,vshft,1)
C      call upack1('pot oves',spot,ovshft)
C      call dcopy(9,w(ovshft),1,ves,1)
C      end

