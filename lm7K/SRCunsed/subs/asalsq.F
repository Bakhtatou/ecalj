Cgetarg...info...           structure ['asalsq', 'ctrl', 'sctrl']
Cgetarg...info...           structure ['asalsq', 'array', 'sarray']
Cgetarg...info...           structure ['asalsq', 'pot', 'spot']
Cgetarg...info...           structure ['asalsq', 'ham', 'sham']
Cgetarg...info...           use_to_add ['asalsq', 'm_struc_def']
      subroutine asalsq(iscr,sctrl,slat,sspec,sarray,sham,sbz,spot,vrl,
     .  qin,qnu)
       
       use m_struc_def  !Cgetarg

C- Linear response, estimate of self-consistent density, ASA
C ----------------------------------------------------------------------
Ci Inputs
Ci   iscr  :0,1 do nothing
Ci         :2,3 read static q=0 response function psta from disk to 
Ci         :    make eps and screen output q and ves
Ci         :4,5 Construct model q=0 response function
Ci         :6,7 like 2, but estimate self-consistent ves only
Ci         (NB: 1s bit reserved for making psta)
Ci   sctrl :struct for program flow parameters; see routine uctrl
Ci     Elts read: nbasp nbas nclass nl nspin
Ci     Stored:    *
Ci     Passed to: asamad
Ci   slat  :struct for lattice information; see routine ulat
Ci     Elts read: *
Ci     Stored:    *
Ci     Passed to: asamad
Ci   sspec :struct for species-specific information; see routine uspec
Ci     Elts read: *
Ci     Stored:    *
Ci     Passed to: asamad
Ci   sarray:structure containing offsets to various arrays
Ci     Elts read: nclasp onrcp oipc ormax
Ci     Stored:    *
Ci     Passed to: asamad
Ci   sham  :struct for parameters defining hamiltonian; see routine uham
Ci     Elts read: ldham oindxo
Ci     Stored:    *
Ci     Passed to: scrmom
Ci   spot  :struct for information about the potential; see routine upot
Ci     Elts read: opnu oves ovintr omad
Ci     Stored:    *
Ci     Passed to: asamad
Ci   qin   :energy-weighted moments of the sphere charges which were
Ci         :used to generate the input potential
Ci   vrl   :(pgf) difference in potential between left- and right- leads,
Ci         :      either because leads are different or because of
Ci         :      a bias across the device; see lmasa-gf.f
Cio Inputs/Outputs
Cio  qnu   :On input, moments generated by the hamiltonian (output moments)
Cio        :On output, qnu is overwritten by :
Cio        :  qin + epsilon^-1 [(qout-qin) - P (Vin -V[qin])]
Cr Remarks
Cr
Cu Updates
Cu   21 Jul 07 (pgf) vne->vrl (for inequivalent left- and right- end layeers)
Cu   24 Feb 05 (Jailei Xu) Screening through model dielectric function
Cu   10 Feb 04 (S.Faleev) vrl added to argument list; passed 
Cu              to asamad for non-equilibrium mode
Cu   26 Apr 03 Added MPI calls
Cu   19 Feb 02 Adapted to padded basis as found in layer GF code
C ----------------------------------------------------------------------
C     implicit none
C ... Passed parameters
      integer iscr
Cgetarg       double precision sctrl(1),sarray(1),spot(1),sham(1),slat(1),
Cgetarg      . sbz(1),sspec(1),qin(1),qnu(1),vrl
       real(8):: qin(1) , qnu(1) , vrl 
       type(s_ctrl)::sctrl
       type(s_array)::sarray
       type(s_pot)::spot
       type(s_ham)::sham
       type(s_lat)::slat
       type(s_bz)::sbz
       type(s_spec)::sspec(*)

C ... Local parameters
      integer fopn,i,ifi,iscr1,ldham(16),lihdim,nRLc,nbas,nbasp,nbaspp,
     .  nclasp,nclass,nclspp,nl,nnrl,nsp,nspc
      integer oidxsh,oipc,omad,onrcp,opnu,opsta,ormax,oveold,oves,
     .  ovintr,ovold
      integer mpipid,procid
      equivalence (lihdim,ldham(3)),(nspc,ldham(4))
      double precision emad,trumad,vmtz(2)
C ... Heap
      integer w(1)
      common /w/ w

      iscr1 = mod(iscr,10)/2
      if (iscr1 .eq. 0) return

C ... Unpack local variables
Cgetarg...info...           integer :: nbasp , integer(8) :: sctrl%nbasp 1
Cgetarg...info...           integer :: nbas , integer(8) :: sctrl%nbas 1
Cgetarg...info...           integer :: nclass , integer(8) :: sctrl%nclass 1
Cgetarg...info...           integer :: nl , integer(8) :: sctrl%nl 1
Cgetarg...info...           integer :: nsp , integer(8) :: sctrl%nspin 1
Cgetarg       call upack('ctrl nbasp nbas nclass nl nspin',sctrl,nbasp,nbas,
Cgetarg      .  nclass,nl,nsp)
       
       nbasp=sctrl%nbasp
       nbas=sctrl%nbas
       nclass=sctrl%nclass
       nl=sctrl%nl
       nsp=sctrl%nspin

Cgetarg...info...           integer :: nclasp , integer(8) :: sarray%nclasp 1
Cgetarg...info...           integer :: onrcp , integer(8) :: sarray%onrcp 1
Cgetarg...info...           integer :: oipc , integer(8) :: sarray%oipc 1
Cgetarg...info...           integer :: ormax , integer(8) :: sarray%ormax 1
Cgetarg       call upack('array nclasp onrcp oipc ormax',sarray,nclasp,onrcp,
Cgetarg      .  oipc,ormax,0)
       
       nclasp=sarray%nclasp
       onrcp=sarray%onrcp
       oipc=sarray%oipc
       ormax=sarray%ormax

Cgetarg...info...           integer :: opnu , integer(8) :: spot%opnu 1
Cgetarg...info...           integer :: oves , integer(8) :: spot%oves 1
Cgetarg...info...           integer :: ovintr , integer(8) :: spot%ovintr 1
Cgetarg       call upack('pot opnu oves ovintr',spot,opnu,oves,ovintr,0,0)
       
       opnu=spot%opnu
       oves=spot%oves
       ovintr=spot%ovintr

      nclspp = 2*nclasp-nclass
Cgetarg...info...           integer :: ldham(16) , integer(8) :: sham%ldham 16
Cgetarg...info...           integer :: oidxsh , integer(8) :: sham%oindxo 1
Cgetarg       call upack('ham ldham oindxo',sham,ldham,oidxsh,0,0,0)
       
       i_copy_size=size(sham%ldham) 
       call i8icopy(i_copy_size,sham%ldham,1,ldham,1) 
       oidxsh=sham%oindxo

      nRLc = nnrl(1,1,nbasp,w(oidxsh),lihdim)
      
C ... MPI: only master does screened mixing
      procid = mpipid(1)
      if (procid .eq. 0) then

      if (iscr1 .eq. 2) then
        call defcc(opsta,1)
      else
        call defcc(opsta,-nRLc*nRLc*nsp*nspc)
      endif

C     Always couple spins?
      nspc = nsp

C ... Read in static response matrix
      if (iscr1 .eq. 1 .or. iscr1 .eq. 3) then
         ifi = fopn('PSTA')
         call iores(nRLc,nsp,nspc,ifi,w(opsta))
C     call prjrsp(nsp,nspc,1,nRLc,1,w(opsta))
      end if

C ... ves[output q]
C     print *, '!!'
      call pshpr(40*0+0)
      call defdr(ovold,nclspp)
      call dcopy(nclspp,w(oves),1,w(ovold),1)
      call asamad(sctrl,spot,sarray,slat,sspec,100,w(opnu),qnu,
     .  vrl,w(oves),emad,trumad,vmtz)
C ... ves[input q]
      call defdr(oveold,nclspp)
      call asamad(sctrl,spot,sarray,slat,sspec,100,w(opnu),qin,
     .  vrl,w(oveold),emad,trumad,vmtz)
      call poppr
C ... screened ves and emom
      i = 4
      if (iscr1 .eq. 2) i = 12
      if (iscr1 .eq. 3) i = 1
Cgetarg...info...           integer :: omad , integer(8) :: spot%omad 1
Cgetarg       call upack1('pot omad',spot,omad)
       
       omad=spot%omad

      nbaspp = 2*nbasp-nbas
      call scrmom(sham,sbz,slat,i,nbasp,nsp,nl,nclasp,w(onrcp),w(oipc),
     .  w(ormax),nRLc,w(opsta),w(omad),nbaspp,w(ovintr),w(ovold),
     .  w(oveold),w(oves),qin,qnu)
      call rlse(opsta)

      endif
      call mpibc1(qnu,3*nl*nsp*nclasp,4,.false.,'asalsq','qnu')

Cgetarg       end
       end subroutine asalsq 


