      subroutine rotwf(opt,nl,nbas,bas,offH,indxsh,istab,g,ag,q,rmat,
     .  ldmpa,ldima,ldz,nev,z0,z)
C- Rotate a wave function z0 into z
C ----------------------------------------------------------------------
Ci Inputs
Ci   opt   :
Ci          1s digit not used now
Ci         10s digit
Ci           0: z is in real spherical harmonics
Ci           2: h is in true (complex) spherical harmonics
Ci            : See cb2sph.f and s2sph.f for definition of true 
Ci            : spherical harmonics.
Ci        100s digit distinguishes how complex arithmetic is handled
Ci           0: h,h0 have real, imaginary separated
Ci              h = h(ldha,ldhb,2), with h(*,*,1..2) = real..imag
Ci           1: h,h0 are in complex*16 format
Ci              h = h(2,ldha,ldhb), with s(1,*) = real, s(2,*) = imag
Ci   nl    :(global maximum l) + 1
Ci   nbas  :number of atoms in the basis (input)
Ci   bas   :basis vectors (input)
Ci   offH  :Offsets to hamiltonian matrix (makidx.f)
Ci   istab :table of site permutations for each group op (symtab.f)
Ci          Site istab(i,ig) is transformed into site i by grp op ig.
Ci          Obtain by calling symtbl with mode=1.
Ci   g,ag  :space group operation; see Remarks
Ci   q     :qp for which z is sought.
Ci   rmat  :a work array of dimension at least nl**4
Ci         :If wave functions use true spherical harmonics, rmat
Ci         :must be dimensioned at least nl**4*2
Ci   ldmpa :offset to current downfolding block
Ci   ldima :last orbital in current downfolding block
Ci   ldz   :dimensions z
Ci   nev   :number eigenvectors to rotate
Ci   z0    :unrotated wave function; see Remarks
Co Outputs
Co   rmat  :rotation matrix for this g
Co   z     :is returned at q
Cr Remarks
Cr   Input vectors z0 are rotated to z.  g must correspond to a group
Cr   operation that maps starting qp to q, i.e. z0 must correspond
Cr   the qp = g^-1 q.  Thus, rotwf applied the rotation R so that
Cr   z(q) = R z0 (g^-1 q).
Cr
Cr   The phase shifts calculated here correspond to the fact that the
Cr   R' as generated by g R_j + ag can differ from the corresponding
Cr   R_i by a lattice translation vector.  The phase shifts below
Cr   adjust for the unwonted shift in ( g R_j + ag - R_i).
Cu Updates
Cu   04 Jan 04 Allow rotation of w.f. represented in true 
Cu             spherical harmonics
Cu   25 Apr 02 first cut at applicability to multiple-kappa basis.
Cu             bug: fp code has different phase convention.
Cu   02 Oct 01 Replace by call to prothl in roth, so downfolding works
C ----------------------------------------------------------------------
C     implicit none
C ... Passed parameters
      integer nkap0,n0H
      parameter (nkap0=3,n0H=5)
      integer opt,ldmpa,ldima,ldz,nev,nl,nbas,istab(nbas),
     .  offH(n0H,nkap0,1),indxsh(1)
      double precision bas(3,nbas),g(3,3),ag(3),q(3),
     .  rmat(nl*nl,nl*nl,2),z(ldz,ldz,2),z0(ldz,ldz,2)
C ... Local parameters
#if OLD
      integer nl2,ibas,jbas,i,j,nlmi,li,offr,offi,offj,nlm,ir,jr,k,
     .  ncut,of0i
      double precision twopi,sp,cosP,sinP,tbas(3)
      double precision zz(ldz,ldz,2),cdabs2
#if SGI
      parameter (ncut=9)
#else
      parameter (ncut=4)
#endif
#else
      integer ofzi,kcplx,ixx,ldzr,opt1,nl2
      double precision wk(nl*nl,nl*nl,2)

      call tcn('rotwf')

      opt1 = mod(mod(opt/10,10),4)
      nl2 = nl*nl

C     call zprm('z0',2,z0,ldz,ldz,nev)
      kcplx = mod(opt/100,10)
      if (kcplx .eq. 1) then
        kcplx = 2
        call ztoy(z0,ldz,ldz,nev,0)
      endif
      call cplxdm(kcplx,ldz,nev,ixx,ixx,ldzr,ofzi)

C     call yprm('z0',kcplx+2,z0,ofzi,ldz,ldz,nev)

      if (opt1 .eq. 0) then
        call ylmrtg(nl2,g,rmat)
      else
        call ylmrtg(nl2,g,wk)
        call s2sph(kcplx,nl,nl,wk,nl2,nl2,nl2,nl2,rmat)
C       call yprm('rmat',kcplx+2,rmat,nl2*nl2,nl2,nl2,nl2)
      endif

      call prothl(10*opt1,nl*nl,nbas,bas,ldmpa,ldima,indxsh,istab,g,ag,
     .  q,rmat,1,nev,1,nbas,0,ldzr,-1,0,z,ofzi,ldzr,ixx,z0,ofzi)

C     call yprm('z(r)',kcplx+2,z,ofzi,ldz,ldz,nev)

      if (mod(opt/100,10) .eq. 1) then
        call ztoy(z0,ldz,ldz,nev,1)
        call ztoy(z,ldz,ldz,nev,1)
      endif

      call tcx('rotwf')
#endif


C --- OLD ... does not work with downfolding ---
#if OLD
      call tcn('rotwf')
      twopi = 8d0*datan(1d0)
      nl2 = nl*nl
      call ylmrtg(nl2,g,rmat)
      call dpzero(z,ldz*ldz*2)

      do  10  ibas = 1, nbas
        jbas = istab(ibas)
C   ... tbas = (g R_j + a) - R_i; tbas should be a lattice vector
        do  14  i = 1, 3
        tbas(i) = ag(i) - bas(i,ibas)
        do  16  j = 1, 3
   16   tbas(i) = tbas(i) + g(i,j)*bas(j,jbas)
   14   continue
C   ... exp(i q tbas)
        sp = twopi*(tbas(1)*q(1) + tbas(2)*q(2) + tbas(3)*q(3))
        cosP = dcos(sp)
        sinP = dsin(sp)

C   ... Offset to first orbital in ibas,jbas
        offi = offH(1,1,ibas)
        offj = offH(1,1,jbas)
        nlm  = offH(1,1,ibas+1) - offH(1,1,ibas)

C   ... For each l, do rmat z0(jbas,lm)
        offr = 1
        do  20  li = 0, nl-1
          offr = li**2 + 1
          nlmi = 2*li+1
          if (indxsh(offj+offr) .gt. ldz) goto 20

          if (nlmi .gt. ncut) then
            call dgemm('N','N',nlmi,ldz,nlmi,1d0,rmat(offr,offr),nl2,
     .        z0(offj+offr,1,1),ldz,0d0,z(offi+offr,1,1),ldz)
            call dgemm('N','N',nlmi,ldz,nlmi,1d0,rmat(offr,offr),nl2,
     .        z0(offj+offr,1,2),ldz,0d0,z(offi+offr,1,2),ldz)
          else
            offr = offr - 1
            ir = offi+offr
            jr = offj+offr
            do  22  k = 1, ldz
            do  22  j = 1, nlmi
            do  22  i = 1, nlmi
            z(i+ir,k,1) = z(i+ir,k,1) + rmat(i+offr,j+offr)*z0(j+jr,k,1)
            z(i+ir,k,2) = z(i+ir,k,2) + rmat(i+offr,j+offr)*z0(j+jr,k,2)
   22       continue
          endif

   20   continue

C        if (abs(sp) .gt. 1d-8) print 333, 'tbas=',ibas,tbas,istab,sp
C  333   format(a,i3,3f14.8,3i3,f14.8)


C   ... Multiply by phase
        if (dabs(sp) .gt. 1d-8) then
          do  30  i = 1, nlm
   30     call yscal(ldz,cosP,sinP,z(offi+i,1,1),z(offi+i,1,2),ldz)
        endif
   10 continue
#endif

#if DEBUG
      ofzi = ldz*ldz
C     zz = 0
      call prothl(opt1,nl2,nbas,bas,0,ldz,indxsh,istab,g,ag,q,rmat,1,
     .  ldz,1,nbas,0,ldz,-1,0,zz,ofzi,ldz,ldz,z0,ofzi)

      do  i = 1, ldz
      do  j = 1, ldz
        if (cdabs2(z(i,j,1)-zz(i,j,1),z(i,j,2)-zz(i,j,2)).ge.1d-12) then
          print *, i,j
          call rx('oops')
        endif
      enddo
      enddo
      call tcx('rotwf')
#endif
      end

