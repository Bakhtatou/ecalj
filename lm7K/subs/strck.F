      subroutine strck(nds,iat,ixi,rtab,e,ikap,nkap,nbas,alpha,halp,
     .  iax,ntab,s,b,nitab,cy,xmrp,la,info,slk,slj)
C- Screened Hankels and their one-center expansion for testing
C ----------------------------------------------------------------
Ci Inputs
Ci   nds   :leading dimensions of s and alpha
Ci   iat   :Site R for which screened Hankel functions are calculated
Ci   ixi   :Indicates site R' for one-center expansion.  ixi is index
Ci         :to pair table relative to start of cluster at iat
Ci         :Thus ixi=1 points to head; ixi=2 points to 1st neighbor, etc
Ci         :ixi is used in two contexts:
Ci         :- point xmrp is defined as position relative to site R'
Ci         :- One-center expansion is to be evaluated around R'
Ci   nbas  :size of basis
Ci   e     :energies of Hankel functions
Ci   nkap,ikap: number of Hankel functions in expansion and which
Ci          function is to be evaluated
Ci   alpha :screening parameters.   See Remarks
Ci   halp  :inverse of head value functions;see makalp io=4 and Remarks
Ci   s     :real-space structure constant matrix:
Ci         :K^alpha_RL = K_R'L' S_R'L',RL
Ci   nitab :number of inequivalent strux
Ci   iax   :neighbor table containing pair information (pairc.f)
Ci         :iax(9,i) = (lmx+1)**2 for basis atom iax(2,i) (mkiaxd)
Ci   ntab  :ntab(ib)=offset to neighbor table for cluster ib (pairc.f)
Ci   rtab  :site positions corresponding to entries in iax table (ppair9)
Ci   cy    :Normalization constants for spherical harmonics
Ci   xmrp  :x-R'
Ci   la    :the l quantum number to which bessel is evaluated
Ci   info  :1s digit>0 use OKA conventions when calculating H; B -> -B
Ci         :100s digit -> S corresponds to (u0,u1); see Remarks.
Co Outputs
Co   slk(L):H^a_(ikap,RL) at x-R'
Co   slj(L):1-C expansion of H^a_(ikap,RL) at x-R', expanded about R'
Cr Remarks
Cr   Evaluates screened envelope function K_mRL at a point x-R'
Cr   The function is defined as
Cr     K^a_mRL(x) = sum_R'' K_R'' * S_m'R''L'',mRL
Cr   where K_R''(x) is the ordinary Hankel function K(x-R'')
Cr
Cr   The same function has a one-center expansion about site R' as
Cr     K^a_mRL = (head term) *delta_m'R'L',mRL + B_m'R'L',mRL *
Cr               [J^a_m'R'L'(x) - H^a_m'R'L'(x) alpha_m'R'L',m]
Cr
Cr   The head term depends on whether S corresponds to linear
Cr   combinations of K^a_mRL(x) that match the unscreened K_mRL(x)
Cr   on the surface of the head sphere for m=1,2, or if they
Cr   are 'value-slope' functions u0 and u1 which have the property
Cr   that u0 is 1 and u1 is zero, and u0' is zero, u1'=1 on the
Cr   surface of the sphere.  They are related by matrix halp,
Cr   generated by makalp.f, io=4.
Cr
Cr   Note: 2nd generation strux (called "Salpha" are -B^alpha here.
Cr   Quantity [..] = [J^a_m'R'L'(x) - H^a_m'R'L'(x) alpha_m'R'L',m]
Cr   should vanish on the surface of R' for all L' by construction
Cr   In the 2-kappa case, the slope of [..] should also vanish.
Cu Updates
Cu   23 Jul 08 (S Lozovoi) Adapted to species-dependent lmax
Cu   05 Aug 06 Updated to handle multiple-kappa strux
Cu   19 May 04 Rewritten in preparation for NMTO
Cu   Original code written for double-kappa basis.
C ----------------------------------------------------------------
C     implicit none
C Passed parameters
      integer iat,ixi,ikap,la,nbas,nds,niax,nitab,nkap,info
      parameter (niax=10)
      integer iax(niax,1),ntab(nbas)
      double precision rtab(3,*),e(nkap),
     .  b(nds,nds,nkap,nkap,nitab),s(nds,nds,nkap,nkap,nitab),
     .  alpha(nds,nbas,nkap,nkap),halp(nds,nbas,nkap,nkap),
     .  cy(1),xmrp(3),slj(25),slk(25)
C Local parameters
      integer j,jj,k,nclus,nlma,nlmb,offR,offRp,iatRp,nlb,ik,ll,lb,
     .  loka,lhalp,getdig
      double precision ddot,hl(49,2),bl(49,2),xmrpp(3)
C     integer L,iatRpp
c     double precision facb

      loka = getdig(info,0,2)
      lhalp = getdig(info,2,2)
C     Offset to iax table for cluster connected to R
      offR  = ntab(iat)
      nclus = ntab(iat+1) - ntab(iat)
C     Offset to iax table for site R'
      offRp = ixi-1 + offR
C     Basis index for site R'
      iatRp = iax(2,offR+ixi)
      nlma  = (la+1)**2
      nlb   = nds*nbas
      call dpzero(slj,nlma)
      call dpzero(slk,nlma)
C     Scale 2nd gen strux outside this routine for consistency
C     facb = 1
C     if (loka .eq. 1) facb = -1

C --- K^alpha = sum_R'' K(x - R'') * S_R''L'', RL ---
      do  j = 1, nclus
C       jj points to (R'',R) pair in strux
        jj = iax(8,offR+j)
        nlmb  = iax(9,offR+j)
        lb = ll(nlmb)

C       Use x - R'' =  (x-R') + (R'-R) - (R''-R)
        do  k = 1, 3
          xmrpp(k) = xmrp(k) - rtab(k,offR+j) + rtab(k,offRp+1)
        enddo

        do  ik = 1, nkap
          call soldhj(xmrpp,e(ik),loka,lb,hl(1,ik),bl(1,ik),cy)
C         Warning!  nlma here need not be nlmb of R'
C         But until B is expanded, it should be that nlma=nlmb(R')
C         call addsb(nlmb,nlma,s(1,1,ik,ikap,jj),hl(1,ik),slk)
          call dgemm('T','N',nlma,1,nlmb,1d0,
     .      s(1,1,ik,ikap,jj),nds,hl(1,ik),nlmb,1d0,slk,nlma)
        enddo
      enddo

C --- K^alpha = sum_R'' K(x - R'') * (1 - alpha * B^alpha)_R''L'', RL ---
C     This accomplishes the same as above, without using S.
C      do  j = 1, nclus
CC       jj points to (R'',R) pair
CC       jj = offR+j
C        jj = iax(8,offR+j)
C        nlmb  = iax(9,jj)
C        lb = ll(nlmb)
C
CC       Use x - R'' =  (x-R') + (R'-R) - (R''-R)
C        do  k = 1, 3
C          xmrpp(k) = xmrp(k) - rtab(k,offR+j) + rtab(k,offRp+1)
C        enddo
CC       print *, '|xmrpp|=',j,dsqrt(ddot(3,xmrpp,1,xmrpp,1))
C
CC   ... Diagonal term delta_R'',R
C        if (j .eq. 1) call soldhj(xmrpp,e(ikap),loka,lb,slk,bl,cy)
C
CC   ... Term K * alpha * B^alpha
C        do  ik = 1, nkap
C          call soldhj(xmrpp,e(ik),loka,lb,hl(1,ik),bl(1,ik),cy)
C        enddo
CC       print 555, 'kalp', hl(1,1),hl(1,2)
C        iatRpp = iax(2,jj)
C        do  ik = 1, nkap
CC       Store tmp bl_L : -sum_(jk) K_(jk)L * alpha_(jk)L,(ik)L
C        do  L = 1, nlmb
C          bl(L,ik) = -ddot(nkap,hl(L,1),49,alpha(L,iatRpp,1,ik),nlb)
C        enddo
CC       Add  into slk : sum_L' tmp_(ik)L' * B_(ik)L',(ikap)L
CC       Warning!  nlma here need not be nlmb of R'
CC       But until B is expanded, it should be that nlma=nlmb(R')
C        call addsb(nlmb,nlma,b(1,1,ik,ikap,offR+j),bl(1,ik),slk)
CC        call dgemm('T','N',nlmb,1,nlma,1d0,
CC     .    s(1,1,ik,ikap,offR+j),nds,bl(1,ik),nlma,1d0,slk,nlmb)
C        enddo
C      enddo

C --- 1-C expansion: K*1 + (J - K alpha) B^alpha at R' ---
C     ib    = iax(1,offRp+1)
      nlmb  = iax(9,offRp+1)
      lb  = ll(nlmb)
C     Warning! alpha should be zero for nlma>nlmb(R')
      do  ik = 1, nkap
        call soldhj(xmrp,e(ik),loka,lb,hl(1,ik),bl(1,ik),cy)
      enddo
      do  ik = 1, nkap
        do  j = 1, nlmb
          bl(j,ik) = bl(j,ik) -
     .               ddot(nkap,hl(j,1),49,alpha(j,iatRp,1,ik),nlb)
        enddo
C       Add to slj: sum_L' J_L' B_L'L
C       Warning!  nlma here need not be nlmb
C       But until B is expanded, it should be that nlma=nlmb
C       call addsb(nlmb,nlma,b(1,1,ik,ikap,offRp+1),bl(1,ik),slj)
        call dgemm('T','N',nlma,1,nlmb,1d0,
     .    b(1,1,ik,ikap,offRp+1),nds,bl(1,ik),nlmb,1d0,slj,nlma)
      enddo
C     Add on-site term: either unity, or rotated if (u0,u1)
      if (ixi .eq. 1) then
C       u_ikap = h1*halp(1,ikap)+h2*halp(2,ikap)
        if (lhalp .eq. 1) then
          do  j = 1, nlmb
            hl(j,ikap) = ddot(nkap,hl(j,1),49,halp(j,iatRp,1,ikap),nlb)
          enddo
        endif
        call daxpy(nlma,1d0,hl(1,ikap),1,slj,1)
      endif

      end

C      subroutine addsb(nlmb,nlma,b,jl,sl)
CC- Add sum_La jl(La)*b(La,Lb) into sl(Lb)
CC ----------------------------------------------------------------
CCi Inputs
CCi
CCo Outputs
CCo
CCr Remarks
CCr   jl*b is added into sl
CC ----------------------------------------------------------------
C      implicit none
CC Passed parameters
C      integer nlma,nlmb
C      double precision b(nlma,nlmb),jl(1),sl(1)
CC Local parameters
C      integer ilm,klm
C      double precision sum
C
C      do  10  ilm = 1, nlmb
C        sum = sl(ilm)
C        do  11  klm = 1, nlma
C   11   sum = sum + jl(klm)*b(klm,ilm)
C        sl(ilm) = sum
C   10 continue
C      end

