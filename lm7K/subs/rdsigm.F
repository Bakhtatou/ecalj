Cgetarg...info...           structure ['rdsigm', 'ham', 'sham']
Cgetarg...info...           structure ['rdsigm', 'lat', 'slat']
Cgetarg...info...           structure ['rdsigm', 'bz', 'sbz']
Cgetarg...info...           use_to_add ['rdsigm', 'm_struc_def']
      subroutine rdsigm(mode,nbas,nsp,ndimh,slat,sham,sbz,ifis,rsrnge,
     .  lwsig)
       
       use m_struc_def  !Cgetarg

C- Read sigm(k) from file and generate sigm(R)
C ----------------------------------------------------------------------
Ci Inputs
Ci   mode  :1s digit
Ci         :0 do not read self-energy; just exit
Ci         :1 read and FT sigma(k) to make sigma(T)
Ci         :2 symmetrize sigma(T)
Ci         :4 take the real part of sigma(T) only
Ci         :10s digit (used here only for printout)
Ci         :0 Simple bloch sum of sigma
Ci         :1 approx high- and low-energy sigma with diagonal
Ci         :2 perturbation approach, diagonalizing exactly only
Ci         :  the first kappa block.
Ci         :3 Linear interpolation of sigma from neighboring p
Ci         :  sig(q) = sum_i wt_i A+_i sig(qpi) A_i
Ci         :  where A_i = z^LDA_qi (z_q^LDA)^-1
Ci         :100s digit specifies number of interpolation points
Ci         :    for interpolation mode 3.
Ci         :  0 -> use default (4 points)
Ci         :1000s digit specifies ASA conventions:
Ci         :      poke sigm(k)_RL,R'L' -> sigm(T)_RL,R'L'
Ci         :      (10000s digit of hft2rs)
Ci         :10000s digit
Ci         :  1 specifies file sigm stored with no group operations
Ci         :    sigm is stored at k-points in the full BZ.
Ci         :    Equivalent to --rsig:fbz
Ci         :  2 do not force R.S. neighbor table to conform to
Ci         :    symmetry
Ci         :  4 do not force file qp to match those generated by
Ci              bzmesh.  Use qp from bzmesh.
Ci   nbas  :size of basis
Ci   nsp   :2 for spin-polarized case, otherwise 1
Ci   ndimh :hamiltonian dimension
Ci   slat  :struct for lattice information; see routine ulat
Ci     Elts read: plat opos nsgrp oistab osymgr oag
Ci     Stored:
Ci     Passed to:
Ci   sbz   :struct for the Brillouin Zone; see routine ubz
Ci     Elts read: nkabc lshft nkp oqp
Ci         : (used only when rdsigm writes sigma on a new mesh)
Ci   ifis  :file logical unit for sigma
Ci   rsrnge:maximum length for connecting vectors in sigma(R)
Cio Inputs/Outputs:
Cio  sham  :struct for parameters defining hamiltonian; see routine uham
Cio    Elts read: ldham ooffH oindxo sigp rsstol
Cio    Stored:    nqsig oqsig ndhrs ontabs oiaxs ohrs
Cio Outputs:
Co   lwsig :0  No special transformations of sigma
Co         :1  Mode transforms sigma from orbital into LDA basis.
Co         :   rdsigm reads sigma from file sigm in orbital basis;
Co         :   Calling program generates and stores transformed sigma
Co         :2  Similar to lwsig=1, except
Co             low- and high- energy blocks replaced by diagonal parts
Co         :-1 Mode transforms sigm from LDA to orbital basis
Co         :   (Inverse operation of lwsig=1 or lwsig=2).
Co         :   This mode requires both sigma and LDA eigenvectors go be
Co         :   stored on disk in files 'sigm' and 'evec'
Co         :   rdsigm generates and stores transformation in file 'sigm2'
Co         :3  Returns lwsig=3 to flag calling program.  It should generate and
Co         :   store LDA eigenvalues and eigenvectors. No sigm file is read.
Co         :4  Returns lwsig=4 to flag calling program.  It should generate and
Co         :   store eigenvalues and eigenvectors.
Co         :5  Writes sigm as in lwsig=2 with low- and high- energy blocks
Co         :   replaced by diagonal parts, but writes sigm in orbital bas.
Cl Local variables
Cl   sigp  :parameters for approximating self-energy sigma.  sigma
Cl         :is approximated by its diagonal part sigii for energies
Cl         :below a low-energy cutoff (specified nmin or emin) and
Cl         :above a low-energy cutoff (specified nmax or emax).
Cl         : arg 1: specifies how to set diagonal part sigii
Cl         :        for states above the high-energy cutoff nmax or emax
Cl         :        0 constrain sigii to be > asig+bsig*e
Cl         :        1 constrain sigii to be = asig+bsig*e
Cl         :        2 constrain sigii to be > asig and < bsig
Cl         :        3 constraint same as case 1.
Cl         :          arg1=3 differs in that the least-squares fit to
Cl         :          sigii (for informational purposes only, to help
Cl         :          estimate asig and bsig) is done for states between
Cl         :          efit and nmax or emax
Cl         : arg 2: nmin : sigma for states 1..nmin are approximated by sigii
Cl         : arg 3: emin : (used only if nmin<0)
Cl         :             : sigma for levels e<emin are approximated by sigii
Cl         : arg 4: nmax : sigma for levels i>nmax are approximated by
Cl         :               sigii AND constrained according to mode
Cl         : arg 5: emax : (used only if nmax<=0)
Cl         :             : sigma for levels e<emax are approximated by
Cl         :               sigii AND constrained according to mode
Cl         : arg 6: asig : constraint used to approximate
Cl         :               sigii = asig + E * bsig  or
Cl         :               asig < sigii < bsig
Cl         : arg 7: bsig : constraint used to approximate
Cl         :               sigii = asig + E * bsig  or
Cl         :               asig < sigii < bsig
Cl         : arg 8: efit : (mode 3) energy minimium
Cl                         for fitting asig and bsig (not used here)
Cl   Note  :sigp takes a similar, but slightly different meaning when
Cl         :used in conjuction with sigm(LDA)->sigm(orbital), i.e. lwsig=-1
Cl         :In this case, sigp applies to the new basis, whose
Cl         :eigenvalues and eigenvectors are stored in 'evec.'
Cl         :Arguments are used in rotevs, with the following relations:
Cl         : arg1 (mode) has same meaning as before
Cl         : arg2 (nmin) takes meaning of lcore.
Cl         :       nmin>0 => sigm does not contain this block,  but the
Cl         :                 new basis does.  Use in emin (arg3) in
Cl         :                 place of sigm for this block .
Cl         :       nmin<0 => new basis does not contain this block
Cl         : arg3 (emin) If nmin>0, use emin for diag. sigma, this block
Cl         : arg4, arg5 (nmax,emax) could play the role of lhigh in
Cl         :       rotevs.  However, they are not used.  lhigh is
Cl         :       determined from constraint ndims+lccore+lhigh = ndimz
Cl
Cl   hreal :0 allow sigm(R) to be complex
Cl         :1 assume sigm(R) is real
Cl  ltrans :specifies indexing of sigm(T)_RL,R'L'L
Cl         : ltrans = F taken from sigm(k)_RL,R'L'
Cl         : ltrans = T taken from sigm(k)_RL,R'L'
Cl  kcplx  :0 sigm(k) has real, imaginary separated
Cl         :1 sigm(k) is in complex*16 format:
Cl         :2 sigm(k) has real, imaginary separated by columns
Cl  lphase :T if phase convention phi = q * [(g R_j + a) - R_i]
Cl         :  for rotations should be scaled by -1
Cl  lssym  :10000s digit mode
Cl  lfbzin :flags whether input self-energy file has suppressed symops
Cl  nscnts :compound of switches containing file contents of sigma
Cl  qoffi  :k-mesh offset for input sigma file
Cl  qoffo  :k-mesh offset for generated sigma file
Cr Remarks
Cb Bugs
Cb   Routine should be able to accomodate offset qp case (ifac<>0)
Cb   Routine should be able to accomodate case when a different
Cb   list of irreducible qp is used than the one generated by
Cb   bzmesh.
Cu Updates
Cu   27 Jun 08 Redesigned transformation of sigma to new basis
Cu   15 May 07 Parallelized symmetrizer
Cu   24 Jan 07 New option --wsig:onesp
Cu   20 Jan 07 Bug fix, --mixsig, spin polarized case
Cu   16 Jan 07 New option lwsig=-1; updated iosigh
Cu   24 Jul 06 MPI broadcast of sigma
Cu   24 Feb 05 Rotation of sigma matrix now in hrs
Cu             Switch lwsig to flag transformed sigm to be generated
Cu   27 Jan 05 New 40000s digit mode (allow qp mismatch)
Cu   20 Dec 04 New --wsig:rot and --wsig:phase switches
Cu             New 10000s digit mode
Cu   22 Nov 04 New --wsig:newkp switch
Cu   25 Sep 04 rdsigm can read sigm(q) file for offset q-mesh
Cu             rdsigm can write sigm(q) for mesh sbz->nkabc
Cu    5 Apr 04 bug fix for --wsig switch.  New --mixsig switch
Cu   15 Feb 04 Enable rdsigm to read a linear combination of
Cu             data from file ifis and data from file 'sigm1'
Cu    4 Jan 04 rdsigm checks bloch sum against ham->rsstol
Cu   10 Oct 03 rdsigm can spin-split a non-spin-polarized sigma
Cu   23 Sep 03 rdsigm can now read sigm fit to ASA hamiltonian
Cu   11 Jul 03 enable write of sigma to full BZ
Cu   24 May 03 Redesigned switches in accord with new interpolation
Cu   09 May 03 Added symmetrization of sigma
Cu   10 Jan 03 Some adaptations for Sergey's interpolation
Cu   14 Aug 02 Added option to orthogonalize sigm.
Cu   27 Jul 02 first created
C ------------------------------------------------------------
      use m_psigd 
C     implicit none
C ... Passed parameters
      integer mode,nbas,ifis,ndimh,lwsig
C     integer osig(nbas),otau(nbas),oppi(nbas)
Cgetarg       double precision slat(1),sham(1),sbz(1)
       type(s_lat)::slat
       type(s_ham)::sham
       type(s_bz)::sbz

C     double precision ssite(1),sspec(1)
      double precision rsrnge
C ... Local parameters
      logical llshft(3),cmdopt,ltrans,lphase,lsplts,lnwmsh,
     .  latvec,lfbzin,lfbzout
      integer parg,isw,lonesp
      character outs*80,out2*80,dc*1,rots*120
      integer i,j,ifis2,ifiz,isp,nsp,nglob,ival,ldham(16),hreal,lrsig,
     .  moditp,nttabs,nkxyz(3),nk1,nk2,nk3,nsgrp,nsgrps,mxkp,nqp,nqps,
     .  ndhrs,j1,k1,k2,k3,iq1,nl,nspc,mxorb,nqsig,modsgp,nmin,nmax,
     .  fopna,kcplx,lrot,iprint,stdo,lssym,ledit,niax,nscnts,
     .  ndims,ndimz,iq,n123(4),lcore,lhigh
      parameter (niax=10)
      equivalence (nk1,nkxyz(1)),(nk2,nkxyz(2)),(nk3,nkxyz(3))
      integer og,oag,ogstar,oipq,oqp,owgt,ooffH,oiprmb,opos,ontabs,
     .  oiaxs,ohrs,ohrss,osfz,owk,oistab,osigm,osigm2,oqsig,odelT,oistb2
      double precision tmp(3)
      double complex ztmp(3)
      real(8),allocatable:: evls(:),evlz(:),sigii(:)
      complex(8),allocatable:: siglda(:,:),z(:,:),sigo(:,:)
C     For offset q mesh
      integer is(3),lshft(3),ifac(3),lqoffo
      double precision rb(3,3),qb(3,3),qoffi(3),qoffo(3)
C MPI
      logical mlog
      integer procid,mpipid,master
C ... for mixing sigma files: Use alf1*sigm + alf2*sigm1
      double precision alf(2)
C     integer os
      double precision plat(3,3),qp(3),tolq,rsstol,sigp(10)
      double precision emin,emax,asig,bsig,efit,qoff(3),rotm(3,3),ddot
      equivalence (emin,sigp(3)),(emax,sigp(5))
      equivalence (asig,sigp(6)),(bsig,sigp(7)),(efit,sigp(8))
C Given (j1,j2,j3) of ipq, q_k(j1,j2,j3) =  sum_i (j_i*ifac(i)-1)*qb(k,i)
      double precision qk
      integer jj1,jj2,jj3,k
C.....titus
C      integer ib,ib1,ib2,nlmaa,lidim,ldh,osfz1,nsp1
C      integer nkap0,n0H
C      parameter  (nkap0=3,n0H=5)
C      integer offH(n0H,nkap0,nbas)
C.....titus
C ... Heap
      integer w(1)
      common /w/ w

      real(8):: eseavr
      integer:: debugmode
ccccccccccccccccccccccccccccccc
c      integer:: oss
ccccccccccccccccccccccccccccccc



      qk(k,jj1,jj2,jj3) = (jj1*ifac(1)-1)*qb(k,1) +
     .                    (jj2*ifac(2)-1)*qb(k,2) +
     .                    (jj3*ifac(3)-1)*qb(k,3)

C --- Setup and printout ---
      procid = mpipid(1)
      master = 0
      mlog = cmdopt('--mlog',6,0,outs)

C     tolq is allowed fuzz in qp
      tolq = 1d-6
      stdo = nglob('stdo')
      ledit = 0
      lrsig = mod(mode,10)
      lwsig = 0
      moditp = mod(mode/10,10)
      alf(1) = 1
      alf(2) = 0
      nscnts = 0
      lqoffo = 0
      lfbzout = .false.

C     Switch flagging whether input file has symops or not
      hreal = 0
      if (lrsig .ge. 4) hreal = 1
      if (lrsig .eq. 0) return

      ltrans = mod(mode/1000,10) .eq. 0
      kcplx = 1
      if (mod(mode/1000,10) .eq. 1) kcplx = 0
      lphase = mod(mode/1000,10) .eq. 0
      lssym = mod(mode/10000,10)
      call isanrg(lssym,0,7,'rdsigm:','10000s digit mode',.true.)

C ... Command-line switches for input sigma and defaults
      call sigflg(' ','rsig',' ',w,w,w,lfbzin,w,
     .  lonesp,qoffi,w)
      if (cmdopt('--rsig',6,0,outs)) then
        out2 = outs(7:)
        dc = out2(1:1)
        call sigflg(dc,'rsig',out2,w,w,w,lfbzin,w,lonesp,qoffi,w)
      endif
#if 1
      if ( lfbzin .or. mod(lssym,2).eq.1 ) then
      lfbzin = .true.
      else
      lfbzin = .false.
      endif
#else
      lfbzin = lfbzin .or. mod(lssym,2)
#endif

      if (cmdopt('--mixsig=',9,0,outs)) then
        j = 0
        i = parg('--mixsig=',4,outs,j,len(outs),
     .        ', ',2,2,ifac,alf)
        if (i .ne. 1 .and. i .ne. 2) call rx
     .    ('rdsigm: failed to parse arguments to --mixsig=')
      endif

      call info(10,1,0,' RDSIGM: read file sigm and create '//
     .  '%?#n#REAL#COMPLEX# sigma(R) by FT ...',hreal,0)
Cgetarg...info...           integer :: ldham(16) , integer(8) :: sham%ldham 16
Cgetarg...info...           integer :: ooffH , integer(8) :: sham%ooffH 1
Cgetarg...info...           integer :: oiprmb , integer(8) :: sham%oindxo 1
Cgetarg...info...           real(8) :: sigp(10) , real(8) :: sham%sigp 10
Cgetarg...info...           real(8) :: rsstol , real(8) :: sham%rsstol 1
Cgetarg       call upack('ham ldham ooffH oindxo sigp rsstol',sham,ldham,ooffH,
Cgetarg      .  oiprmb,sigp,rsstol)
       
       i_copy_size=size(sham%ldham) 
       call i8icopy(i_copy_size,sham%ldham,1,ldham,1) 
       ooffH=sham%ooffH
       oiprmb=sham%oindxo
       i_copy_size=size(sham%sigp) 
       call dcopy(i_copy_size,sham%sigp,1,sigp,1) 
       rsstol=sham%rsstol

      modsgp = nint(sigp(1))
      nmin   = nint(sigp(2))
      nmax   = nint(sigp(4))
      call info2(30,0,0,
     .  '%9fSigm will be approximated by:  '//
     .  '%?#(n==0)#Simple bloch sum##%-1j'//
     .  '%?#(n==1)#diagonal Sigma for high and low states##%-1j'//
     .  '%?#(n==2)#Perturbation for higher kappa blocks##%-1j'//
     .  '%?#(n==3)#Interpolation from known points##%-1j'//
     .  ' ',moditp,0)
      if (moditp .eq. 1 .or. moditp .eq. 2) then
        call info5(30,0,0,
     .    '%9fApproximate sigma '//
     .    '%?#(n<0)#for energies E(lda)<%d; and %-2j#%-1j#'//
     .    '%?#(n>0)#for states up to %-1jn=%i; and ##%j'//
     .    '%?#(n<=0)#for energies E(lda)>%d%-2j#%-1j#'//
     .    '%?#(n>0)#for states above %-1jn=%i##%j',
     .    nmin,emin,nmax,emax,0)
        call info5(30,0,0,'%9fFor high states '//
     .    '%?#(n==0)#Sigii > %,3;4d + %,3;4d * E(lda)%-2j##%-1j'//
     .    '%?#(n==1)#Sigii = %,3;4d + %,3;4d * E(lda)%-2j##%-1j'//
     .    '%?#(n==3)#Sigii = %,3;4d + %,3;4d * E(lda)%-2j##%-1j'//
     .    '%?#(n==2)#%,3;4d < Sigii < %,3;4d%-2j##%-1j'//
     .    ' ',modsgp,asig,bsig,0,0)
        if (nmax .gt. 0) call info5(30,0,0,
     .    '%9fLinear fit to diagonal sigma for E(lda)>%d'//
     .    '%?#(n==3)# and n<%i'//
     .    ' ',efit,modsgp,nmax,0,0)
        if (nmax .eq. 0) call info5(30,0,0,
     .    '%9fLinear fit to diagonal sigma for E(lda)>%d'//
     .    '%?#(n==3)# and E(lda)<%d'//
     .    ' ',efit,modsgp,emax,0,0)
        call isanrg(modsgp,0,3,'rdsigm:','sig fit mode',.true.)
      endif
      if (lfbzin .or. ddot(3,qoffi,1,qoffi,1).ne.0) then
        call info5(30,0,0,
     .  '%?#(n==1)#%9fFile sigm in saved in FBZ: '//
     .  'symmetrization suppressed##'//
     .  '%?#(n==1)#%N%9fFile k-mesh is offset by:%3:2g#%j#'//
     .  ' ',isw(lfbzin),isw(ddot(3,qoffi,1,qoffi,1).ne.0),qoffi,0,0)
        endif

      if (alf(1) .ne. 1 .or. alf(2) .ne. 0) then
        call info5(30,0,0,
     .    '%9fUse for sigma: %d*(file sigm)%?#n# + '//
     .    '%d*(file sigm1)',alf(1),isw(alf(2).ne.0),alf(2),0,0)
      endif

C ... Setup for sigm transformation modes
      if (cmdopt('--wsig',6,0,outs) .or. cmdopt('-wsig',5,0,outs)) then
      if (procid .eq. master) then
        out2 = outs(7:)
        if (outs(1:5) .eq. '-wsig') out2 = outs(6:)
        dc = out2(1:1)
        call sigflg(dc,'wsig',out2,ledit,lwsig,lrot,lfbzout,lnwmsh,
     .    lonesp,qoffo,rots)
        lqoffo = isw(ddot(3,qoffo,1,qoffo,1) .ne. 0)

C       Setup, sigm transformation modes
        if (lwsig .ne. 0) then

          call info5(10,0,0,
     .      '%9ftrans=%i:%19p'//
     .      '%?#(n==-1)#transform sigm, LDA -> orbital'//
     .      ' basis (file sigm3)##%-1j'//
     .      '%?#(n==1|n==2)#transform sigm, orbital ->'//
     .      ' LDA basis (file sigm2)##%-1j'//
     .      '%?#(n==5)#transform sigm, orbital ->'//
     .      ' orbital basis (file sigm2)##%-1j'//
     .      '%?#(n==2|n==5)#%N%19fhigh-energy block approximated by'//
     .      ' a diagonal matrix##%-1j'//
     .      '%?#(n==3)#make LDA eigenvalues, eigenvectors##%-1j'//
     .      '%j%?#(n==1)#%N%19fshift k-mesh by%3:2g#%j#'//
     .      '%?#(n==1)#%N%19fsigma in FBZ##'//
     .      ' ',lwsig,lwsig,lqoffo,qoffo,isw(lfbzout))

C     ... Transform sigm(lda)->sigm(orbital)
          if (lwsig .eq. -1) then

C         Read dimension of hamiltonian in evec file
C         Check that evec file contains LDA eigenvectors
          call info0(30,0,0,'%9fchecking compatibility between '//
     .        'sigm2, evec files ...')
          ifiz = fopna('evec',-1,4)
          rewind ifiz
          call iosigh(2,3,i,ndimz,nk1,nk2,nk3,nqp,lshft(1),lshft(2),
     .      lshft(3),ifiz)
C         Verify that sigm2 file contains sigm(LDA); read dimension
          ifis = fopna('sigm2',-1,4)
          call iosigh(0,nscnts,i,ndims,nk1,nk2,nk3,nqp,lshft(1),
     .      lshft(2),lshft(3),ifis)
          if (nscnts .ne. 1 .and. nscnts .ne. 2)
     .       call rx1('File sigm2 (trans=%i) does not contain '//
     .        'sigm(LDA): create with trans=1 or 2 ',nscnts)
C         Check that evec file matches (nsp,nqp)
          rewind ifiz
          if (lfbzin) nqp = nk1*nk2*nk3
          call iosigh(3,3,i,ndimz,nk1,nk2,nk3,nqp,lshft(1),lshft(2),
     .      lshft(3),ifiz)

          allocate(evls(ndims),evlz(ndimz),sigii(ndimz))
          allocate(siglda(ndims,ndims),z(ndimz,ndimz),sigo(ndimz,ndimz))

C         Write header for sigm3
          ifis2 = fopna('sigm3',-1,4)
          call iosigh(0,0,nsp,ndimz,nk1,nk2,nk3,nqp,
     .      lshft(1),lshft(2),lshft(3),-ifis2)

C         For each qp, rotate sigm(lda)->sigm(orb)
          do  iq = 1, nqp
C         Check that qp match
          read(ifis) qp, eseavr !add eseavr june2009 
          print *,' uuu1 eseavr=',iq,eseavr
          read(ifiz) tmp
          call daxpy(3,-1d0,qp,1,tmp,1)
          if (ddot(3,tmp,1,tmp,1) .gt. 1d-9)
     .      call rx('rdsigm : qp mismatch, files sigm and evec')
          call dpdump(evls,ndimh,ifis)
          call dpdump(siglda,ndims**2*2,ifis)
          call dpdump(evlz,ndimz,ifiz)
          call dpdump(z,ndimz**2*2,ifiz)
          call info5(30,0,0,' rdsigm:  kpt %i of %i, k=%3:2,5;5d',
     .      iq,nqp,qp,0,0)
          write(stdo,542)
  542     format(8x,'Elda(evec)   Elda(sig)    diff       sig_ii',
     .      '      a+b*Elda')
          do  i = 1, ndimz
            write(stdo,543) i, evlz(i), evls(i),  evlz(i)-evls(i),
     .        dble(siglda(i,i)),asig+bsig*evlz(i)
  543       format(i5,5f12.6)
          enddo

C          print *, '!!'; sigp(2) = 2

C         Determine lhigh = ndimz - ndims - lcore
C         sigp(4) = nmax = ndimz - lhigh = ndims + lcore
          sigp(4) = ndims + sigp(2)

C          print *, '!!'; ndimz = ndimz+5
C          deallocate(evlz,sigii)
C          allocate(evlz(ndimz),sigii(ndimz))
C          evlz = evls(ndims)+1
C          evlz(1:2) = -99
C          evlz(1+2:ndims+2) = evls(1:ndims)
C          evlz(ndimz) = 11

          call dpzero(sigii,ndimz)
          call psigd(1,ndimz,ztmp,evlz,sigp,n123,sigii)
          lcore = nint(sigp(2))
          lhigh = ndimz - ndims - lcore
          call rotevs(1,ndimz,ndims,lcore,lhigh,w,siglda,sigii,z,sigo)
          ifis2 = fopna('sigm3',-1,4)
          write(ifis2) qp
          call dpdump(sigo,ndimh**2*2,-ifis2)
          enddo

          deallocate(evls,evlz,sigii)
          deallocate(siglda,z,sigo)

          call rx0('RDSIGM:  sigm(orbital basis) saved in file sigm3')

          endif

C         No sigma for LDA eigenvectors; early exit
          if (lwsig .eq. 3 .or. lwsig .eq. 4) return

        endif
      endif
      endif

      call tcn('rdsigm')

C --- Read sigma(orbital basis) from file ---

C ... Read k-mesh parameters
      if (procid .eq. master) then
C       Require file contains sigm(orbital basis)
        call iosigh(0,nscnts,i,j,nk1,nk2,nk3,nqp,lshft(1),lshft(2),
     .    lshft(3),ifis)
        if (nscnts .ne. 0 .and. nscnts .ne. 5) then
        call iosigh(2,0,i,j,nk1,nk2,nk3,nqp,lshft(1),lshft(2),
     .    lshft(3),ifis)
        endif
      endif

      call mpibc1(i,1,2,.false.,'rdsigm','nsp')
      call mpibc1(nkxyz,3,2,mlog,'rdsigm','nkxyz')
      call mpibc1(nqp,1,2,mlog,'rdsigm','nqp')
      call mpibc1(lshft,3,2,mlog,'rdsigm','lshft')
      if (i .eq. nsp) then
        lsplts = .false.
      elseif (i .gt. nsp) then
        call rx(
     .    'rdsigm: sigm file spin polarized but calculation is not')
      else
        lsplts = .true.
      endif

C     Check for consistency in remaining ndimh, nqp
C     and set file sigma file pointer past header
      if (procid .eq. master) then
        rewind ifis
        if (lfbzin) nqp = nk1*nk2*nk3
        call iosigh(3,nscnts,i,ndimh,nk1,nk2,nk3,nqp,
     .    lshft(1),lshft(2),lshft(3),ifis)
      endif
      call mpibc1(nkxyz,3,2,mlog,'rdsigm','nkxyz')
      call mpibc1(nqp,1,2,mlog,'rdsigm','nqp')
      call mpibc1(lshft,3,2,mlog,'rdsigm','lshft')
      call info5(30,0,0,'%9fsigm file has %i irreducible QP: nk ='//
     .    ' ( %i %i %i )  shift=%3:1l',nqp,nk1,nk2,nk3,lshft)
C     Sanity checks
      if (lsplts) call info0(30,0,0,
     .  '%9f(warning) sigm file not spin pol .. splitting spins')
Cgetarg...info...           real(8) :: plat(3,3) , real(8) :: slat%plat 9
Cgetarg...info...           integer :: opos , integer(8) :: slat%opos 1
Cgetarg       call upack('lat plat opos',slat,plat,opos,0,0,0)
       
       i_copy_size=size(slat%plat) 
       call dcopy(i_copy_size,slat%plat,1,plat,1) 
       opos=slat%opos

Cgetarg...info...           integer :: nsgrp , integer(8) :: slat%nsgrp 1
Cgetarg...info...           integer :: oistab , integer(8) :: slat%oistab 1
Cgetarg...info...           integer :: og , integer(8) :: slat%osymgr 1
Cgetarg...info...           integer :: oag , integer(8) :: slat%oag 1
Cgetarg       call upack('lat nsgrp oistab osymgr oag',slat,nsgrp,oistab,og,
Cgetarg      .  oag,0)
       
       nsgrp=slat%nsgrp
       oistab=slat%oistab
       og=slat%osymgr
       oag=slat%oag

C     Get leading dimension of hrs
      call offsHp(w(oiprmb),1,nbas,2,0,ndimh,0,ndhrs)
C     Setup for FFT
      call fftz30(nk1,nk2,nk3,k1,k2,k3)
      if (nk1.ne.k1 .or. nk2.ne.k2 .or. nk3.ne.k3) call rx(
     .  'rdsigm: not ready for FFT w/ dimensions ne no div.')
C ... Number of group operations for input file sigma
      if (mod(lssym,2) .eq. 0) nsgrps = nsgrp
      if (mod(lssym,2) .eq. 1) nsgrps = 1
      if (lfbzin) nsgrps = 1
C ... Make is,ifac,qb,qlat,qoff
      do  8  i = 1, 3
    8 llshft(i) = lshft(i) .ne. 0
      call pshpr(0)
      call bzmsh0(plat,llshft,0,nk1,nk2,nk3,is,ifac,rb,qb)
      call poppr
      do  i = 1, 3
        qoff(i) = qk(i,1,1,1) + qoffi(i)
      enddo

C ... Setup for r.s. hamiltonian: allocate and create iax,ntab; allocate hrs
      i = 1000 + 10*hreal + 0
C      print *, '!!'; i = 1000*0 + 10*hreal + 0
      if (mod(lssym,4) .ge. 2) i = 10*hreal + 0
      if (ltrans) i = i + 10000
      if(debugmode()>0) print *,' go to hft2rs i=',i
      call hft2rs(i,nk1,nk2,nk3,k1,k2,k3,qoff,1,nsp,nbas,w(og),w(oag),
     .  nsgrp,rsrnge,w(ooffH),1,nbas,ndimh,ndimh,w,plat,w(opos),ontabs,
     .  oiaxs,ndhrs,w)
      nttabs = ival(w(ontabs),nbas+1)
C     Allocate memory for hrs
      if (hreal .eq. 1) then
        call defdr(ohrs,-ndhrs**2*nttabs*nsp)
      else
        call defdc(ohrs,-ndhrs**2*nttabs*nsp)
      endif

c      stop 'xxxxxxxxxxxxxxxx takao test1 in rdsigm.F xxxxxxxxxx'



C --- Get list of irreducible k-points, and ipq and gstar arrays ---
      mxkp = nk1*nk2*nk3
      call defrr(oqsig,3*mxkp)
      call defdr(oqp,3*mxkp)
      call defi(ogstar,-mxkp-1)
      w(ogstar) = -2
      call defi(oipq,mxkp)
      call defdr(owgt,-mxkp)
      call info(20,1,0,
     .  ' q-points in full BZ where sigma calculable ...',0,0)
      call bzmesh(plat,qb,nk1,nk2,nk3,llshft,w,0,w(oipq),
     .  w(oqsig),w(owgt),nqsig,mxkp,0,0)
Cgetarg...info...           integer :: nqsig , integer(8) :: sham%nqsig 1
Cgetarg...info...           integer :: oqsig , integer(8) :: sham%oqsig 1
Cgetarg       call pack2('ham nqsig oqsig',sham,nqsig,oqsig)
       
       sham%nqsig=nqsig 
       sham%oqsig=oqsig 

      call dpzero(w(owgt),mxkp)
      call info2(20,0,0,
     .  ' Irr. qp for which sigma is calculated ...',0,0)
      call bzmesh(plat,qb,nk1,nk2,nk3,llshft,w(og),nsgrps,w(oipq),
     .  w(oqp),w(owgt),nqps,mxkp,w(ogstar),0)
      call isanrg(nqp,nqps,nqps,'rdsigm','file sigm nqp',.true.)
C     call prmx('q for which sigma is read',w(oqp),3,3,nqp)
      call info2(30,0,0,
     .  '%?#(n==1)#%1fFile sigm has k-offset=%3:2g '//
     .  'relative to the above#%j#'//
     .  ' ',isw(ddot(3,qoffi,1,qoffi,1).ne.0),qoffi)

C ... titus
CC     List of sites
C      call getoffH(w(ooffH),offH,n0H,nkap0,nbas)
C      ib1 = 1
C      ib2 = nbas
C      lidim = offH(4,1,nbas+1)
C
C      print*,'lidim',lidim
C
C      do 100 ib = ib1, ib2
C      rewind ifis
C      call iosigh(0,nscnts,nsp1,ndimh,nk1,nk2,nk3,nqp,
C     .  lshft(1),lshft(2),lshft(3),ifis)
C      nlmaa = offH(4,1,ib+1) - offH(4,1,ib)
C      print*,'nlmaa',nlmaa
C      print*,'offH(4,1,ib)',offH(4,1,ib)
C      print*,'offH(4,1,ib+1)',offH(4,1,ib+1)
C ... titus

C --- Generate hrs = sigma(T) from file sigma(k) ---
C ... Loop over spins, keeping sig in full BZ for only one spin
      if (procid .eq. master) then
      do  isp = 1, nsp

C     If sigma file not spin polarized, use sigma from spin 1
      if (isp .eq. 2 .and. lsplts) then
        call iosigh(3,0,1,ndimh,nk1,nk2,nk3,nqp,
     .    lshft(1),lshft(2),lshft(3),ifis)
      endif

C     If to mix in some other sigma file, set up ifis2
      if (alf(2) .ne. 0) then
      if (isp .eq. 1 .or. isp .eq. 2 .and. lsplts) then
        ifis2 = fopna('sigm1',-1,4)
        call iosigh(3,0,nsp,ndimh,nk1,nk2,nk3,nqp,
     .    lshft(1),lshft(2),lshft(3),ifis2)
      endif
      endif

C ... File sigma in irr BZ -> sigma in full BZ by rotations
      call defcc(osfz,k1*k2*k3*ndimh**2)
C ... titus
C      call defcc(osfz,k1*k2*k3*ndimh*nlmaa)
C      call defcc(osfz1,k1*k2*k3*ndimh*nlmaa)
C ... titus
      call defcc(owk,ndimh**2)
      nl = nglob('nl')
      nspc = 1
      call defcc(osigm,ndimh**2)
ccccccccccccccccccccccccc
ctakaox
c      call defcc(oss,ndimh**2)
ccccccccccccccccccccccccc
      do  iq1 = 1, nqps
        read(ifis) qp,  eseavr !june2009  add eseavr
        print *,' uuu2 iq1 eseavr=',iq1,eseavr
        call dpscop(qp,tmp,3,1,1,1d0)
        call dpsadd(tmp,w(oqp),3,1,3*iq1-2,-1d0)
        call dpsadd(tmp,qoffi,3,1,1,-1d0)
        if (.not. latvec(1,tolq,plat,tmp)) then
          call dpscop(w(oqp),tmp,3,3*iq1-2,1,1d0)
          if (lssym .ge. 4) then
            call info5(20,0,0,' rdsigm (warning) qp %i : '//
     .        'expected%3;8,4D read%3;8,4D',iq1,tmp,qp,0,0)
            call dpscop(tmp,qp,3,1,1,1d0)
          else
            print 456, iq1,tmp,qp
  456     format(' rdsigm: error on reading qp no',i4/
     .           ' Expected qp=',3f12.6/
     .           '     File qp=',3f12.6)
          call rx(' incompatible q-mesh')
        endif
        endif
C       File read sigma
        if (nscnts .eq. 5) call dpdump(tmp,1,ifis)
        call dpdump(w(osigm),ndimh**2*2,ifis)
C        if (isp .eq. 2) then
C          print *, iq1,isp
C         call zprm('sigm',2,w(osigm),ndimh,ndimh,ndimh)
C        endif

cccccccccccccccccccccccccccccccccccccc
ctakaox !see also bndfp.F and hambls.F
c        if(iq1==1) then
c          print *,'reading ovlmat'
c          ifio = fopna('ovlmat',-1,4)
c        endif
c        call dpdump(w(oss),ndimh**2*2,ifio)
c        print *,'read ovlmat for iq1=',iq1
c        call divctakao(w(osigm),w(oss),ndimh)
ccccccccccccccccccccccccccccccccccccc

        if (alf(1) .ne. 1d0) then
          call dscal(ndimh**2*2,alf(1),w(osigm),1)
        endif
        if (alf(2) .ne. 0d0) then
          read(ifis2) qp
          call dpscop(qp,tmp,3,1,1,1d0)
          call dpsadd(tmp,w(oqp),3,1,3*iq1-2,-1d0)
          call dpsadd(tmp,qoffi,3,1,1,-1d0)
          if (abs(tmp(1))+abs(tmp(2))+abs(tmp(3)) .gt. tolq) then
            call dpscop(w(oqp),tmp,3,3*iq1-2,1,1d0)
            if (lssym .ge. 4) then
              call info5(20,0,0,' rdsigm (warning) qp %i : '//
     .          'expected%3;8,4D read%3;8,4D (file sigm1)',iq1,tmp,qp,
     .          0,0)
            else
              call rx(' file sigm1 has incompatible irr mesh')
            endif
          endif
C         call dpsadd(qp,w(oqp),3,1,3*iq1-2,1d0)
          call defcc(osigm2,ndimh**2)
          call dpdump(w(osigm2),ndimh**2*2,ifis2)
          call daxpy(ndimh**2*2,alf(2),w(osigm2),1,w(osigm),1)
          call rlse(osigm2)
        endif
C       call zprm('sigm',2,w(osigm),ndimh,ndimh,ndimh)

        i = 100*kcplx + 00
        if (lphase) i = i+40
C ... titus
C        call hamfb2(nbas,nl,w(ooffH),w(oiprmb),ib,i,w(opos),iq1,nk1,
C     .    nk2,nk3,k1,k2,k3,w(oipq),w(oistab),w(og),w(oag),
C     .    w(ogstar),ifac,lidim,ndimh,nlmaa,ndimh,nlmaa,nspc,qb,
C     .    w(osigm),w(owk),
C     .    w(owk),w(osfz),w(osfz1))
C ... titus
        call hamfb3(nbas,nl,w(ooffH),w(oiprmb),i,w(opos),iq1,nk1,
     .    nk2,nk3,k1,k2,k3,w(oipq),w(oistab),w(og),w(oag),
     .    w(ogstar),ifac,ndimh,ndimh,ndimh,nspc,qb,w(osigm),w(owk),
     .    w(owk),w(osfz))
      enddo


cccccccccccccccccccccccccccccccccccccccccccc
ctakaox !see also bndfp.F and hambls.F
c      print *,' end of iq1 loop'
c      call fclose(ifio)
c      call rlse(oss)
c      print *,' end of iq1 loop xxxx'
cccccccccccccccccccccccccccccccccccccccccccc



C      print *, 'one element of sigma(k)'
C      call pvtrod(w(osfz),k1,k2,k3,ndimh)

C ... FT sfz and copy sfz(T) to hrs
      i = 10*hreal + 1
      if (ltrans) i = i + 10000
C ... titus
C      call hft2rs(i,nk1,nk2,nk3,k1,k2,k3,qoff,isp,nsp,nbas,w(og),w(oag)
C     .  ,nsgrps,rsrnge,w(ooffH),ib,ib,nlmaa,ndimh,w(osfz),plat,
C     .  w(opos),ontabs,
C     .  oiaxs,ndhrs,w(ohrs))
C ... titus
      call hft2rs(i,nk1,nk2,nk3,k1,k2,k3,qoff,isp,nsp,nbas,w(og),w(oag),
     .  nsgrps,rsrnge,w(ooffH),1,nbas,ndimh,ndimh,w(osfz),plat,w(opos),
     .  ontabs,oiaxs,ndhrs,w(ohrs))

C      print *, 'print out sigma(T)'
C      call pvtrof(w(ohrs),ndhrs,nsp,nk1,nk2,nk3,w(oiaxs),1,
C     .  nttabs,w(osfz),ndimh)
C      stop

C ... End loop over spins
      call rlse(osfz)
      enddo
C ... titus
C 100  continue
C     exit of MPI master loop
      endif
      call rlse(ogstar)

Cgetarg...info...           integer :: ndhrs , integer(8) :: sham%ndhrs 1
Cgetarg...info...           integer :: ontabs , integer(8) :: sham%ontabs 1
Cgetarg...info...           integer :: oiaxs , integer(8) :: sham%oiaxs 1
Cgetarg...info...           integer :: ohrs , integer(8) :: sham%ohrs 1
Cgetarg       call pack5('ham ndhrs ontabs oiaxs ohrs',sham,ndhrs,ontabs,oiaxs,
Cgetarg      .  ohrs,0)
       
       sham%ndhrs=ndhrs 
       sham%ontabs=ontabs 
       sham%oiaxs=oiaxs 
       sham%ohrs=ohrs 


C ... Check that FT replicates sigma(k) at file qp to tolerance rsstol
C     rsstol = 1d-6
C     print *, '!!'
C     if (alf(1) .ne. 1 .or. alf(2) .ne. 0 .or. .true.) then
      if (alf(1) .ne. 1 .or. alf(2) .ne. 0) then
        call info0(20,0,0,' skipping check of Bloch summed sigma'//
     .    ' (sigma scaled) ')
      else
        j1 = 0
        if (lssym .ge. 4) j1 = 2
        if (procid .eq. master) then
          call dpzero(tmp,3)
          call chksgr(j1,ltrans,kcplx,plat,nsp,ndimh,ifis,hreal,
     .      w(oiprmb),nttabs,w(oiaxs),w(ohrs),ndhrs,rsstol,i,w(oqp),
     .      nbas,0,rotm,w)
        endif
      endif

      if (.not. (cmdopt('--wsig',6,0,outs).or.cmdopt('-wsig',5,0,outs)))
     .  call rlse(oqp)

C ... Broadcast R.S. sigma before symmetrization
      if (hreal .eq. 1) then
        call mpibc1(w(ohrs),ndhrs**2*nttabs*nsp,4,mlog,'rdsigm','hrs')
      else
        call mpibc1(w(ohrs),2*ndhrs**2*nttabs*nsp,4,mlog,'rdsigm','hrs')
      endif

C --- Symmetrize hrs ---
C     Best to use nsgrp here instead of nsgrps.
C     However, neighbor table was generated for nsgrps, and may be
C     increase if nsgrp>nsgrps.  This branch will fail in that case.
      if (mod(lrsig,4) .ge. 2 .and. nsgrp .gt. 1) then

C       Allocate memory for hrs
        if (hreal .eq. 1) then
          call defdr(ohrss,ndhrs**2*nttabs*nsp)
          call dcopy(ndhrs**2*nttabs*nsp*1,w(ohrs),1,w(ohrss),1)
        else
          call defdc(ohrss,ndhrs**2*nttabs*nsp)
          call dcopy(ndhrs**2*nttabs*nsp*2,w(ohrs),1,w(ohrss),1)
        endif
        mxorb = nglob('mxorb')
C       10s digit distributes ri-rj pairs to avg (ri-rj),(rj-ri) pairs
C       Use 10*2 for hermitian matrices, 10*1 for symmetric ones
        i = 1-hreal + 10*2 + 100*(1-hreal) + 100000
        call defi(oistb2,nsgrp*nbas)
        call istbpm(w(oistab),nbas,nsgrp,w(oistb2))
        nl = nglob('nl')
        call rsmsym(i,plat,mxorb,w(oiprmb),ndimh,nbas,w(opos),nl,nsp,1,
     .    nttabs,w(ontabs),w(oiaxs),w(og),w(oistb2),nsgrp,ndhrs,
     .    w(ohrss),w(ohrs))
        call rlse(ohrss)

C        Debugging
C        ifis2 = fopna('out',-1,0)
C        print *, 'hello',ndhrs,nttabs
C        call ywrm(0,'sig',2,ifis2,'(9f20.10)',w(ohrs),1,ndhrs**2,
C     .    ndhrs**2,nttabs*nsp)
C        call rx0('done')

C   ... Check how well symmetrized FT replicates sigma(k) at file qp
        if (procid .eq. master) then
        rsstol = 0
        if (alf(1) .ne. 1 .or. alf(2) .ne. 0) then
          call info0(20,0,0,' skipping check of symmetrized sigma'//
     .    ' (sigma scaled) ')
        else
          call chksgr(0,ltrans,kcplx,plat,nsp,ndimh,ifis,hreal,
     .      w(oiprmb),nttabs,w(oiaxs),w(ohrs),ndhrs,rsstol,i,0,
     .      nbas,0,rotm,w)
        endif
      endif

C   ... Broadcast R.S. sigma after symmetrization
        if (hreal .eq. 1) then
          call mpibc1(w(ohrs),ndhrs**2*nttabs*nsp,4,mlog,'rdsigm','hrs')
        else
        call mpibc1(w(ohrs),2*ndhrs**2*nttabs*nsp,4,mlog,'rdsigm','hrs')
        endif

      endif

C ... lwsig=0 modes that internally transform sigma, save and exit
      if (lwsig .eq. 0) then
      if (cmdopt('--wsig',6,0,outs) .or. cmdopt('-wsig',5,0,outs)) then
      if (procid .eq. master) then
        ifis2 = fopna('sigm2',-1,4)
        rsstol = 0
        out2 = outs(7:)
        if (outs(1:5) .eq. '-wsig') out2 = outs(6:)
        dc = out2(1:1)
        call sigflg(dc,'wsig',out2,ledit,lwsig,lrot,lfbzout,lnwmsh,
     .    lonesp,qoffo,rots)

        if (lonesp .eq. 1) then
          if (nsp .eq. 1) call rx(
     .      'onesp option nonsensical unless sigma file is spin pol')
          call siged(1,nbas,nsp,ndhrs,plat,w(opos),ndimh,w(oiprmb),
     .      hreal,w(ontabs),w(oiaxs),w(ohrs))
        endif

        if (ledit .eq. 1) then
          call siged(0,nbas,nsp,ndhrs,plat,w(opos),ndimh,w(oiprmb),
     .      hreal,w(ontabs),w(oiaxs),w(ohrs))
        endif

C       Handle case q-mesh for file output differs from file input
C       ltmp = true in cases where file symops artificially reduced
C        ltmp = mod(lssym,2) .eq. 1 .and. lwsig .ne. 3
C        if (lnwmsh .or. ltmp) then
        if (lnwmsh) then
Cgetarg...info...           integer :: nkxyz(3) , integer(8) :: sbz%nkabc 3
Cgetarg...info...           integer :: lshft(3) , integer(8) :: sbz%lshft 3
Cgetarg...info...           integer :: nqp , integer(8) :: sbz%nkp 1
Cgetarg...info...           integer :: oqp , integer(8) :: sbz%oqp 1
Cgetarg           call upack('bz nkabc lshft nkp oqp',sbz,nkxyz,lshft,nqp,oqp,0)
           
           i_copy_size=size(sbz%nkabc) 
           call i8icopy(i_copy_size,sbz%nkabc,1,nkxyz,1) 
           i_copy_size=size(sbz%lshft) 
           call i8icopy(i_copy_size,sbz%lshft,1,lshft,1) 
           nqp=sbz%nkp
           oqp=sbz%oqp


          mxkp = nk1*nk2*nk3
          call defdr(oqp,3*mxkp)
          call defi(ogstar,-mxkp-1)
          w(ogstar) = -2
          call defi(oipq,mxkp)
          call defdr(owgt,-mxkp)
          do  i = 1, 3
            llshft(i) = lshft(i) .ne. 0
          enddo
          call dpzero(w(owgt),mxkp)
          if (lfbzout) then
            call info0(20,1,0,
     .        ' Creating sigma for new mesh, full BZ (file sigm2) ...')
            call bzmesh(plat,qb,nk1,nk2,nk3,llshft,w,0,w(oipq),
     .        w(oqp),w(owgt),nqp,mxkp,0,0)
          else
            call info0(20,1,0,
     .        ' Creating sigma for new mesh (file sigm2) ...')
            call bzmesh(plat,qb,nk1,nk2,nk3,llshft,w(og),nsgrp,w(oipq),
     .        w(oqp),w(owgt),nqp,mxkp,w(ogstar),0)

          endif

        elseif (lfbzout) then
          oqp = oqsig
          nqp = nqsig
          call info2(20,1,0,
     .      ' Creating sigma for full BZ, %i qp (file sigm2) ...',nqp,0)
        else
          call info2(20,0,0,
     .      ' Writing sigma for irr BZ, %i qp (file sigm2) ...',nqp,0)
        endif

C   ... Setup rotation matrix
        if (rots .ne. ' ') then
          call a2rotm(rots,.false.,0,rotm)
          if (iprint() .ge. 20) then
            call info0(20,0,0,' Rotate sigma by rotation matrix:')
            write (stdo,350) ((rotm(i,j),j=1,3),i=1,3)
  350       format(3f11.6)
          endif
          lrot = lrot + 1
        endif

C   ... Setup phase matrix
        if (lrot .ge. 2) then
          call defrr(odelT,-3*nbas)
          call info0(0,0,0,' Phase shift of sigma.  '//
     .      'Translation vectors from shorps file:')
          call iopos(.false.,-1,'shorps',nbas,w(odelT))
        endif
C       call prmx('q for which sigm is written',w(oqp),3,3,nqp)

        call iosigh(0,nscnts,nsp,ndimh,nk1,nk2,nk3,nqp,
     .    lshft(1),lshft(2),lshft(3),-ifis2)
        if (lqoffo .ne. 0) then
C         call prmx('qp',w(oqp),3,3,nqp)
          do  i = 1, nqp
            call dmsadd(w(oqp),1,qoffo,1,1,3,1,1,3*i-2,1,1d0)
          enddo
C         call prmx('qp',w(oqp),3,3,nqp)
        endif
        call chksgr(1,ltrans,kcplx,plat,nsp,ndimh,ifis2,hreal,
     .    w(oiprmb),nttabs,w(oiaxs),w(ohrs),ndhrs,rsstol,nqp,
     .    w(oqp),nbas,lrot,rotm,w(odelT))
        call fclose(ifis2)
        call rx0('done writing sigma, file sigm2')
C      elseif (lwsig .eq. 1 .or. lwsig .eq. 2) then
C        if (lfbzout) call info0(20,0,0,' ')
C        if (lfbzout) goto 99
      endif
      endif
      endif

C     Broadcast entire sham structure (shouldn't be needed)
C     call mpibc1(sham,i,4,mlog,'rdsigm','sham')
C     Broadcast neighbor table (shouldn't be needed)
C     call mpibc1(w(ontabs),nbas+1,2,mlog,'rdsigm','ntabs')
C     call mpibc1(w(oiaxs),niax*nttabs,2,mlog,'rdsigm','iaxs')

C ... Transformations done by caller: write qp list to disk
   99 continue
      if (lwsig .ne. 0) then

      call info0(30,0,0,' ')

      if (lnwmsh) then
Cgetarg...info...           integer :: nkxyz(3) , integer(8) :: sbz%nkabc 3
Cgetarg...info...           integer :: lshft(3) , integer(8) :: sbz%lshft 3
Cgetarg...info...           integer :: nqp , integer(8) :: sbz%nkp 1
Cgetarg...info...           integer :: oqp , integer(8) :: sbz%oqp 1
Cgetarg         call upack('bz nkabc lshft nkp oqp',sbz,nkxyz,lshft,nqp,oqp,0)
         
         i_copy_size=size(sbz%nkabc) 
         call i8icopy(i_copy_size,sbz%nkabc,1,nkxyz,1) 
         i_copy_size=size(sbz%lshft) 
         call i8icopy(i_copy_size,sbz%lshft,1,lshft,1) 
         nqp=sbz%nkp
         oqp=sbz%oqp

        call info2(20,0,0,
     .    ' Transform sigma on new k-mesh:  '//
     .    'nk=%3:1i  shft=%3:1l',nkxyz,lshft)
        endif

      if (lfbzout) then
        mxkp = nk1*nk2*nk3
        call info(20,0,0,' rdsigm: use full BZ (%i q-points)...',mxkp,0)
        call defdr(oqp,3*mxkp)
        call defi(oipq,mxkp)
        call defdr(owgt,-mxkp)
Cgetarg...info...           real(8) :: plat(3,3) , real(8) :: slat%plat 9
Cgetarg         call upack('lat plat',slat,plat,0,0,0,0)
         
         i_copy_size=size(slat%plat) 
         call dcopy(i_copy_size,slat%plat,1,plat,1) 

C   ... Make is,ifac,qb,qlat
        do   i = 1, 3
          llshft(i) = lshft(i) .ne. 0
        enddo
        call pshpr(0)
        call bzmsh0(plat,llshft,0,nk1,nk2,nk3,is,ifac,rb,qb)
        call poppr
        call bzmesh(plat,qb,nk1,nk2,nk3,llshft,w,0,w(oipq),
     .    w(oqp),w(owgt),nqp,mxkp,0,0)
C       call pack2('bz nkp oqp',sbz,nqp,oqp)
        call rlse(owgt)
      endif

C ... Write points to disk, shifting by qoffo
      if (lqoffo .ne. 0) then
C       call prmx('qp',w(oqp),3,3,nqp)
        do  i = 1, nqp
          call dmsadd(w(oqp),1,qoffo,1,1,3,1,1,3*i-2,1,1d0)
        enddo
C       call prmx('qp',w(oqp),3,3,nqp)
      endif

      call info0(30,0,0,' RDSIGM: writing data to file QPTS ...')
      ifiz = fopna('qpts',-1,0)
      call getqp(1,-ifiz,nqp,nkxyz,lshft,0,w(oqp),w,w)

      if (lfbzout) then
        call rlse(oipq)
      endif

      endif

      call tcx('rdsigm')

Cgetarg       end
       end subroutine rdsigm 

      subroutine iosigh(optio,mode,nsp,ndimh,nk1,nk2,nk3,nqp,
     .  lshft1,lshft2,lshft3,ifi)

C- Read/write header information in sigma file
C ----------------------------------------------------------------------
Ci Inputs
Ci   optio :(read only) 1s digit
Ci         :0 read header data into
Ci            nsp,ndimh,nk1,nk2,nk3,nqp,lshft1,lshft2,lshft3
Ci         :1 File data must passed matched value for
Ci            nsp,ndimh,nk1,nk2,nk3,nqp,lshft1,lshft2,lshft3
Ci         :2 file mode must passed matched value
Ci         :These digits may be taken in any combination
Ci   ifi   :File logical unit: ifi>0 for read; ifi<0 for write
Cio Inputs/Outputs
Cio  mode  : switches with information about the contents of sigma
Cio        :1s digit:
Cio        :0 file contains sigma in the orbital basis
Cio        :1 file contains sigma in the lda basis, and LDA
Cio           eigenvalues
Cio        :2 file contains sigma in the lda basis, and LDA
Cio           eigenvalues
Cio        :3 file consists of LDA eigenvectors and eigenvalues
Cio        :4 file consists of LDA eigenvectors and eigenvalues
Cio        :5 file contains sigma in the orbital basis, and LDA
Cio           eigenvalues
Cio  nsp   :2 for spin-polarized case, otherwise 1
Cio  ndimh :dimension of hamiltonian
Cio  nk1..nk3 : number of divisions in 1st,2nd,3rd Qlat
Cio  nqp   :number of irr. k-points
Cio  lshft1:1 if offset BZ in Qlat(1), otherwise 0
Cio  lshft2:1 if offset BZ in Qlat(2), otherwise 0
Cio  lshft3:1 if offset BZ in Qlat(3), otherwise 0
Cl Local variables
Cr Remarks
Cr   Reads or writes header file for sigma, with sanity checks
Cr   sigm file contents: (1s digit mode = 0..3,5,6)
Cr    1.  header
Cr    2.  qp offset (version 2 and later)
Cr    ... 3 and 4 are repeated for nqp points (nqp is contained in header)
Cr    3.  qp
Cr    4.  sigm(qp) or ham(qp)
Cr   sigm file contents: (1s digit mode = 1 or 3)
Cr    1.  header
Cr    2.  qp offset (version 2 and later)
Cr    ... 3..5 are repeated for nqp points (nqp is contained in header)
Cr    3.  qp
Cr    4.  eval(LDA)
Cr    5.  sigm(LDA) (mode 1) or evec(LDA) (mode 3)
Cu Updates
Cu   27 Jun 08 Revised mode, and input checking.  Old optio=1 -> optio=3
C ----------------------------------------------------------------------
C     implicit none
C ... Passed parameters
      integer nsp,ndimh,nk1,nk2,nk3,nqp,lshft1,lshft2,lshft3,ifi,optio,
     .  mode
C ... Local parameters
      integer jfi,i1,i2,i3,i4,i5,i6,i7,i8,i9,ivsn,modef
      if (ifi .lt. 0) then
        ivsn = 1
C       if (mode .eq. 0) ivsn = 0
        jfi = -ifi
        rewind jfi
C       Write 0 => file contains version number (versions 1 and later)
        if (ivsn .ne. 0) write(jfi) 0, ivsn, mode
        write(jfi) nsp,ndimh,nk1,nk2,nk3,nqp,lshft1,lshft2,lshft3
      elseif (optio .eq. 0) then
        rewind ifi
C       Read version, checking whether header is pre- version 1
        read(ifi,err=99,end=99) i1,ivsn,mode
C       File header is pre-version 1; set version to zero
        if (i1 .ne. 0) then
          ivsn = 0
          mode = 0
          rewind ifi
        endif
        read(ifi,err=99,end=99)
     .    nsp,ndimh,nk1,nk2,nk3,nqp,lshft1,lshft2,lshft3
      else
        rewind ifi
C       Read version, checking whether header is pre- version 1
        read(ifi,err=99,end=99) i1,ivsn,modef
C       File header is pre-version 1; set version, modef to zero
        if (i1 .ne. 0) then
          ivsn = 0
          modef = 0
          rewind ifi
        endif
C       Assign mode or check with file correspondence
        if (mod(optio/2,2) .ne. 0) then
          call isanrg(modef,mode,mode,'iosigh:','file''s mode',.true.)
        else
          mode = modef
        endif
C       Assign header parameters or check with file correspondence
        if (mod(optio,2) .ne. 0) then
        read(ifi,err=99,end=99) i1,i2,i3,i4,i5,i6,i7,i8,i9
        call isanrg(i1,nsp,nsp,'iosigh:','file''s nsp',.true.)
        call isanrg(i2,ndimh,ndimh,'iosigh:','file''s ndimh',.true.)
        call isanrg(i3,nk1,nk1,'iosigh:','file''s nk1',.true.)
        call isanrg(i4,nk2,nk2,'iosigh:','file''s nk2',.true.)
        call isanrg(i5,nk3,nk3,'iosigh:','file''s nk3',.true.)
        call isanrg(i6,nqp,nqp,'iosigh:','file''s nqp',.true.)
        call isanrg(i7,lshft1,lshft1,'iosigh:','file''s lshft1',.true.)
        call isanrg(i8,lshft2,lshft2,'iosigh:','file''s lshft2',.true.)
        call isanrg(i9,lshft3,lshft3,'iosigh:','file''s lshft3',.true.)
        else
          read(ifi,err=99,end=99)
     .    nsp,ndimh,nk1,nk2,nk3,nqp,lshft1,lshft2,lshft3
        endif
      endif
      return

   99 continue
      call rx('iosigh: failed to read header from file')
Cgetarg       end
       end subroutine iosigh 


      subroutine chksgr(opt,ltrans,kcplx,plat,nsp,ndimh,ifis,hreal,
     .  iprmb,nttabs,iaxs,hrs,ndhrs,tols,nqp,qplst,nbas,lrot,rotm,
     .  delT)

C- Compare Bloch summed sigma against file sigma(k)
C ----------------------------------------------------------------------
Ci Inputs
Ci   opt   :1s digit
Ci         :0 calculate sigma at list of qp in file,
Ci         :  compare against file sigma
Ci         :1 calculate sigma at list of qp, write to file sigma
Ci         :  NB: caller must write header to sigma file before
Ci         :  calling chksgr!
Ci         :2 like opt=0, but use qplst instead of qp
Ci   plat  :primitive lattice vectors, in units of alat
Ci   nsp   :2 for spin-polarized case, otherwise 1
Ci   ndimh :dimension of hamiltonian
Ci   ifis  :file logical unit for sigma
Ci   hreal :0 sigm(R) is complex
Ci         :1 sigm(R) is real
Ci   iprmb :permutations ordering orbitals in l+i+h blocks (makidx.f)
Ci   nttabs:number of site pairs in sigm(R)
Ci   iaxs  :neighbor table for sigm(R)
Ci   hrs   :sigm(R)
Ci   ndhrs :leading dimensions of hrs
Ci   tols  :deviations in sigma > tols causes chksgr to abort
Ci         :tols=0 -> chksgr never aborts
Ci   qplst :(opt=0) not used
Ci         :(opt=1) list of qp at which to make sigma
Ci   lrot  :(opt=0) not used
Ci         :(opt=1) 0 -> do not rotate sigma matrix
Ci         :        1 -> rotate sigma matrix by rotm
Ci         :        2 -> additionally scale sigma matrix by phase
Ci         :             owing to change in shortening of basis
Ci         :             vectors
Ci   rotm  :(opt=0) not used
Ci         :(opt=1) list of qp at which to make sigma
Ci   delT  :(only used if lrot=2)
Ci         :change in lattice translation vectors on rotation
Ci         :to add phase shift to sigm.
Cio Inputs/Outputs
Cio  nqp   :Input, opt=0:  number of qp for which sigma was checked
Cio        :Output, opt=1: number of qp for which to make sigma
Cio  (opt=1) sigma written to logical unit ifis
Cl Local variables
Cl   sq    :(opt=0) file's contents of sigma, for comparison
Cl         :(opt=1) temporary array in rotating sigma
Cl   sq1   :bloch-summed sigma
Cr Remarks
Cr
Cu Updates
Cu   20 Dec 04 enable rotation of sigma before writing
Cu   11 Jul 03 enable write of sigma
Cu   09 May 03 First created
C ----------------------------------------------------------------------
C     implicit none
C ... Passed parameters
      integer opt,kcplx,hreal,ifis,ndimh,nsp,nttabs,ndhrs,nqp,lrot
      integer niax,n0,nkap0
      parameter (niax=10, n0=10, nkap0=3)
      integer iprmb(*),iaxs(niax,*),nbas
      double precision plat(3,3),tols,qplst(3,nqp),rotm(3,3),
     .  delT(3,nbas)
      double complex hrs(ndhrs,ndhrs,nsp,nttabs)
      logical ltrans
C ... Local parameters
      logical lsplts
      integer i,j,isp,nglob,stdo,iq1,nl,mxorb,ipr,lgunit,isw,opt0,opt01,
     .  nscnts
      integer ib,jb,is,norb,ltab(n0*nkap0),ktab(n0*nkap0),offl(n0*nkap0)
C     these are read by sigma header
      integer nk1,nk2,nk3,lshft(3),offh(nbas),ndim(nbas),offi,offj,
     .  ndi,ndj
C     integer os
      double precision qp(3),errmxx,errmx,err,qpr(3),xx
      double complex hwk(ndhrs,ndhrs)
#if F90
      complex(8),allocatable:: sq(:,:),sq1(:,:),uz(:,:)
C     complex(8),allocatable:: h(:,:),s(:,:)
#else
      double complex sq(ndimh,ndimh),sq1(ndimh,ndimh),uz(ndimh,ndimh)
#endif
C ... Heap
      integer w(1)
      common /w/ w
      integer ii,jj

      call getpr(ipr)
      stdo = lgunit(1)
      nl = nglob('nl')
      mxorb = nglob('mxorb')
      opt01 = mod(mod(opt,10),2)
      opt0  = mod(opt,10)
      nscnts = 0

#if F90
      allocate(sq(ndimh,ndimh),sq1(ndimh,ndimh))
#endif

C --- Rotate hrs if switch set ---
      if (opt01 .ne. 0 .and. mod(lrot,2) .ne. 0) then
#if F90
        allocate(uz(ndimh,ndimh))
#endif
        call rothrm(2,0,ndimh,iprmb,rotm,1,nbas,ndimh,uz,uz)
C       call zprm('Uz',2,uz,ndimh,ndimh,ndimh)
C       Table of hamiltonian offsets and site dimensions
        do  ib = 1, nbas
          call orbl(ib,0,ndimh,iprmb,norb,ltab,ktab,j,offl,ndim(ib))
          offh(ib) = j+1
        enddo

C       For each pair and spin, rotate hrs to U(ib) hrs U(jb)+
        do  is = 1, nttabs
          ib = iaxs(1,is)
          jb = iaxs(2,is)
          offi = offh(ib)
          offj = offh(jb)
          ndi = ndim(ib)
          ndj = ndim(jb)

          do  isp = 1, nsp

C           U1 sigm(unrotated) U2+
            if (ltrans) then
C             ltrans: use (U1 h+ U2+)+ = (U1 (U2 h)+)+ = U2 h U1+
              call zgemm('N','N',ndj,ndi,ndj,(1D0,0D0),Uz(offj,offj),
     .        ndimh,hrs(1,1,isp,is),ndhrs,(0D0,0D0),hwk,ndhrs)
C              call zprm('U S',2,hwk,ndhrs,ndj,ndi)
C             U sigm(unrotated) U+
              call zgemm('N','C',ndj,ndi,ndi,(1D0,0D0),hwk,ndhrs,
     .          Uz(offi,offi),ndimh,(0D0,0D0),hrs(1,1,isp,is),ndhrs)
C              call zprm('U S U+',2,hrs(1,1,isp,is),ndhrs,ndhrs,ndhrs)
            else
C             Make U1 h U2+
              call zgemm('N','N',ndi,ndj,ndi,(1D0,0D0),Uz(offi,offi),
     .        ndimh,hrs(1,1,isp,is),ndhrs,(0D0,0D0),hwk,ndhrs)
C             call zprm('U S',2,hwk,ndhrs,ndi,ndj)
C             U sigm(unrotated) U+
              call zgemm('N','C',ndi,ndj,ndj,(1D0,0D0),hwk,ndhrs,
     .          Uz(offj,offj),ndimh,(0D0,0D0),hrs(1,1,isp,is),ndhrs)
C             call zprm('U S U+',2,hrs(1,1,isp,is),ndhrs,ndhrs,ndhrs)
            endif

          enddo
        enddo
      endif

C ... Read header data
      lsplts = .false.
      if (opt01 .eq. 0) then
        call iosigh(0,nscnts,i,ndimh,nk1,nk2,nk3,nqp,
     .    lshft(1),lshft(2),lshft(3),ifis)
        if (nscnts .ne. 0 .and. nscnts .ne. 5) then
          call iosigh(2,0,i,ndimh,nk1,nk2,nk3,nqp,
     .      lshft(1),lshft(2),lshft(3),ifis)
        endif

        if (i .eq. nsp) then
          lsplts = .false.
        elseif (i .gt. nsp) then
          call rx(
     .      'rdsigm: sigm file spin polarized but calculation is not')
        else
          lsplts = .true.
        endif
      endif

      do  isp = 1, nsp
      errmxx = 0

C     If sigma file not spin polarized, use sigma from spin 1
      if (isp .eq. 2 .and. lsplts) then
        call iosigh(1,nscnts,1,ndimh,nk1,nk2,nk3,nqp,
     .    lshft(1),lshft(2),lshft(3),ifis)
      endif

C ... For each q, compare Bloch sum of hrs against file's s(q)
C     or write to file
      do  iq1 = 1, nqp

C       print *, 'starting iq=',iq1

        if (opt01 .eq. 0) then
          read(ifis) qp
          if (opt0 .eq. 2) call dcopy(3,qplst(1,iq1),1,qp,1)
          if (nscnts .eq. 5) call dpdump(xx,1,ifis)
          call dpdump(sq,ndimh**2*2,ifis)
          call ztoyy(sq,ndimh,ndimh,ndimh,ndimh,kcplx,1)
C          print *, iq1
C          call zprm('sq',2,sq,ndimh,ndimh,ndimh)
        else
          call dcopy(3,qplst(1,iq1),1,qp,1)
        endif
C       Call bloch : 104010=perm orb, transpose, c*16
        i = 100000 + 4000 + 40*(1-hreal) + 10
        if (.not. ltrans) i = i - 4000
        call bloch(i,qp,nl,plat,mxorb,iprmb,1,nttabs,iaxs,
     .    hrs,ndhrs,isp,nsp,ndimh,ndimh,0,ndimh,0,ndimh,0,sq1,w,w)
C        print *, 'iq=',iq1,'qp=',sngl(qp)
C        call zprm('sigm',2,sq1,ndimh,ndimh,ndimh)
        errmx = 0

C       Compare Bloch sum of hrs against file's s(q)
        if (opt01 .eq. 0) then
        ii = 1
        jj = 1
        do  j = 1, ndimh
          do  i = 1, ndimh
            err = abs(sq(i,j)-sq1(i,j))
            if (err .gt. errmx) then
              ii = i
              jj = j
              if (err .gt. tols .and. tols .gt. 0) then
                print 357, i,j, sngl(err),sq1(i,j),sq(i,j)
  357           format(/
     .            '   i   j',6x,'diff',14x,'bloch sum',16x,'file value'/
     .            2i4,f12.6,2x,2f12.6,2x,2f12.6)
                call rx1('rdsigm: Bloch sum deviates more than'//
     .            ' allowed tolerance (tol=%g)',tols)
            endif
            endif
            errmx = max(errmx,err)
          enddo
        enddo
        if (ipr .ge. 45) write(stdo,332) iq1,errmx,ii,jj
  332   format(' comparing s(iq) to interpolated sq for iq=',i4,
     .    '  errmx=',1pe8.1:' at i,j=',2i4)
        errmxx = max(errmxx,errmx)

C   ... Write to s(q)
        else

C     ...  Rotation of sigma(k) (no longer needed, because hrs(T) was rotated)
C          if (mod(lrot,2) .ne. 0) then
C
CC           call zprm('unrotated S',2,sq1,ndimh,ndimh,ndimh)
C
CC           U sigm(unrotated)
C            call zgemm('N','N',ndimh,ndimh,ndimh,(1D0,0D0),
C     .        Uz,ndimh,sq1,ndimh,(0D0,0D0),sq,ndimh)
CC           call zprm('U S',2,sq,ndimh,ndimh,ndimh)
CC           U sigm(unrotated) U+
C            call zgemm('N','C',ndimh,ndimh,ndimh,(1D0,0D0),
C     .        sq,ndimh,Uz,ndimh,(0D0,0D0),sq1,ndimh)
C            call zprm('U S U+',2,sq1,ndimh,ndimh,ndimh)
C
C          endif

C         Additional scaling by phase shifts
          if (lrot .ge. 2) then
C           call zprm('unscaled S',2,sq1,ndimh,ndimh,ndimh)
            call dgemm('T','N',3,1,3,1d0,plat,3,qp,3,0d0,qpr,3)
C           call prmx('q in units of qlat',qpr,3,3,1)
            call rothph(02,qpr,delT,ndimh,iprmb,1,nbas,ndimh,sq1)
C           call zprm('scale S by phase',2,sq1,ndimh,ndimh,ndimh)
          endif

C         Rotate qp to new coordinate system
          if (mod(lrot,2) .ne. 0) then

C           In-line multiply avoids bug in DEC fort compiler
            do  i = 1, 3
              qpr(i) = rotm(i,1)*qp(1) +
     .                 rotm(i,2)*qp(2) +
     .                 rotm(i,3)*qp(3)
            enddo
            call dcopy(3,qpr,1,qp,1)
          endif

C         Write qp, sigm for this qp
          write(ifis) qp
          call dpdump(sq1,ndimh**2*2,-ifis)
C         call zprm('sigm',2,sq1,ndimh,ndimh,ndimh)
        endif
      enddo

      if (opt01 .eq. 0)
     .  call info5(20,0,0,' check FT s(R) against s(q) ... '//
     .  'maximum error = %;2g%?#n>0# < tol (%;2g)#%j#%?#n==2# spin 2##',
     .  errmxx,isw(tols.ne.0),tols,isp,0)

      enddo

#if F90
      deallocate(sq,sq1)
#endif
      if (opt01 .ne. 0 .and. mod(lrot,2) .ne. 0) then
#if F90
        deallocate(uz)
#endif
      endif

Cgetarg       end
       end subroutine chksgr 


      subroutine siged(mode,nbas,nsp,ndhrs,plat,pos,ndimh,iprmb,hreal,
     .  ntab,iax,hrs)

C- Sigma editor
C ----------------------------------------------------------------------
Ci Inputs
Ci   mode  :compound of these digits:
Ci         :1s digit 1 : merge up and down spins, and exit
Ci   nbas  :size of basis
Ci   nsp   :2 for spin-polarized case, otherwise 1
Ci   ndhrs :dimensions hrs
Ci   plat  :primitive lattice vectors, in units of alat
Ci   pos   :basis vectors
Ci   ndimh :hamiltonian dimension
Ci   iprmb :permutations ordering orbitals in l+i+h blocks (makidx.f)
Ci   hreal :1 if hrs is real
Ci   ntab  :ntab(ib)=offset to neighbor table for cluster ib (pairc.f)
Ci   iax   :neighbor table containing pair information (pairc.f)
Cio Inputs/Outputs
Cio  hrs   :real-space hamiltonian, which may be modified on exit
Cl Local variables
Cl         :
Cr Remarks
Cr
Cu Updates
Cu   01 May 06 First created
C ----------------------------------------------------------------------
C     implicit none
C ... Passed parameters
      integer mode,nbas,nsp,ndhrs,ndimh,iprmb(1),hreal
      integer n0,nkap0,n0H,niax
      double precision plat(3,3),pos(3,nbas)
      parameter (n0=10,nkap0=3,n0H=5,niax=10)
      integer iax(niax,1),ntab(*)
      double precision hrs(2,ndhrs,ndhrs,nsp,1)
C ... Local parameters
      character outs*150, strn*80
      integer nw,ix(10),iwk(10),it1,it2,a2vec,i,j,stdo,nglob
      integer ltab(n0*nkap0),ktab(n0*nkap0),offl(n0*nkap0),
     .  blks(n0*nkap0),ntabh(n0*nkap0)
      integer it,ib,jb,iorb,i1,l1,ik1,norb,j1,j2,isp,isub(4)
      double precision xx(10),rr,drr2,vlat(3),rcut,dglob
      logical lin

C ... Default range: all pairs
      it1 = 1
      it2 = ntab(nbas+1)
      stdo = nglob('stdo')
      rcut = 2
      if (hreal .ne. 0) call rx('siged not ready for hreal')

C ... Merge up, down spin potentials into average
C     print *, dsum(2*ndhrs*ndhrs*nsp*it2,hrs,1)
      if (mod(mode,10) .eq. 1) then
        do  i = it1, it2
C         print *, i
C         call zprm('h1,i',2,hrs(1,1,1,1,i),ndhrs,ndhrs,ndhrs)
C         call zprm('h2,i',2,hrs(1,1,1,2,i),ndhrs,ndhrs,ndhrs)
          call daxpy(2*ndhrs*ndhrs,1d0,hrs(1,1,1,2,i),1,
     .      hrs(1,1,1,1,i),1)
        enddo
        do  i = it1, it2
          call dcopy(2*ndhrs*ndhrs,hrs(1,1,1,1,i),1,hrs(1,1,1,i,1),1)
C         call zprm('hi',2,hrs(1,1,1,i,1),ndhrs,ndhrs,ndhrs)
        enddo
C       print *, dsum(2*ndhrs*ndhrs*it2,hrs,1)

        call dscal(2*ndhrs*ndhrs*it2,0.5d0,hrs,1)
C       print *, dsum(2*ndhrs*ndhrs*it2,hrs,1)
        nsp = 1
        rr = dglob('nsp',1d0,1)
        return
      endif

C      print *, '!!'
C      call dvset(hrs,1,2*ndhrs*ndhrs*nsp*it2,-1d0)

   99 print 301
  301 format(//
     .  ' Welcome to the sigma file editor.')
  306 format(' Failed to parse string ',a,' ... try again.')
  100 continue
#if PRTNOCR
      print '('' Option (enter ? for menu) : '',$)'
#else
      print '('' Option (enter ? for menu) : '')'
#endif
      outs = ' '
      read(*,'(a150)') outs
      call locase(outs)
      if (.false.) then
      elseif (outs .eq. ' ') then
        print '('' Enter ''''q'''' to exit, ''''a'''' to abort'')'
        goto 100

C ... Specify pair
      elseif (outs(1:4) .eq. 'pair') then
        call words(outs,nw)
        if (nw .eq. 1) then
          it1 = 1
          it2 = ntab(nbas+1)
        else
          i = 5
          nw = a2vec(outs,len(outs),i,2,', ',2,-3,2,ix,iwk)
          if (nw .le. 0) then
            print 306, outs(4:)
            goto 100
          else if (nw .eq. 1) then
            iwk(2) = iwk(1)
          endif
          it1 = min(iwk(1),iwk(2))
          it2 = max(iwk(1),iwk(2))
        endif

        ib = iax(1,it1)
        jb = iax(2,it1)

        if (it1 .eq. it2) then
          print '('' edit pair'',i6,''   ib ='',i4,''   jb ='',i4)',
     .      it1,ib,jb

          ib = iax(1,it1)
          isub(1) = 1
          call orbl(ib,0,ndimh,iprmb,norb,ltab,ktab,xx,offl,isub(2))
          jb = iax(2,it1)
          isub(3) = 1
          call orbl(jb,0,ndimh,iprmb,norb,ltab,ktab,xx,offl,isub(4))
        else
          print '('' edit range'',i5,''  to'',i5)', it1,it2
        endif
        goto 100

C ... Summarize hamiltonian for this pair
      elseif (outs(1:3) .eq. 'sum' .and. it1 .eq. it2) then

        ib = iax(1,it1)
  125   continue
        call orbl(ib,0,ndimh,iprmb,norb,ltab,ktab,xx,offl,xx)
        call gtbsl1(4,norb,ltab,ktab,xx,xx,ntabh,blks)
        write(stdo,359) ib
  359   format(/
     .    ' Summary of hamiltonian subblocks for site',i4/
     .    '     kap  lstart  h(k)    h(rs)     size'/
     .    '                 start    range')

        do  iorb = 1, norb
        if (blks(iorb) .ne. 0) then
C         l1,ik1 = l and kaph indices, needed for sigma
          l1  = ltab(iorb)
          ik1 = ktab(iorb)
C         i1 = orbital index in iprmb order; ilm1 = augm. index in L order
          i1 = offl(iorb)
          outs = ' '
          call awrit2('%i,%i',outs,len(outs),0,1+i1-offl(1),
     .                i1-offl(1)+blks(iorb))
          print '(3i7,5x,a10,i3)', ik1, l1, 1+i1, outs(1:10), blks(iorb)
        endif
        enddo
        if (iax(2,it1) .ne. ib) then
          ib = iax(2,it1)
          goto 125
        endif
        print *, ' '

        goto 100

C ... Summarize pair table
      elseif (outs(1:3) .eq. 'sum' ) then

        write(stdo,356)
  356   format(/
     .    ' Summary of pair table for R.S. sigma'/
     .    ' site  start   end  size')
        do  ib = 1, nbas
          write(stdo,357) ib,ntab(ib)+1,ntab(ib+1),ntab(ib+1)-ntab(ib)
  357     format(i4,2i7,i5)
        enddo

        goto 100

C ... Get subblock of hrs
      elseif (outs(1:3) .eq. 'sub') then

        ib = iax(1,it1)
        isub(1) = 1
        call orbl(ib,0,ndimh,iprmb,norb,ltab,ktab,xx,offl,isub(2))
        jb = iax(2,it1)
        isub(3) = 1
        call orbl(jb,0,ndimh,iprmb,norb,ltab,ktab,xx,offl,isub(4))
        call words(outs,nw)
        if (nw .gt. 1) then
          call word(outs,2,j1,j2)
          i = j1-1
          nw = a2vec(outs,len(outs),i,2,', ',2,-3,4,ix,iwk)
          if (nw .ne. 4) then
            print 306, outs(j1:)
          else
            call icopy(4,iwk,1,isub,1)
          endif
          goto 100
        endif

C ... Mask subblock of hrs
      elseif (outs(1:4) .eq. 'mask' .and. it1 .eq. it2) then

        call words(outs,nw)
        if (nw .eq. 1) then
          print *, 'no subblocks specified ... nothing to mask'
          goto 100
        endif

        do  i = isub(1), isub(2)
        do  j = isub(3), isub(4)

C         See whether (i,j) is inside any mask
          lin = .false.
          do  i1 = 2, nw
            call word(outs,i1,j1,j2)
            l1 = j1-1
            j1 = a2vec(outs,len(outs),l1,2,', ',2,-3,4,ix,iwk)
            if (j1 .ne. 4) then
              print 306, outs(i1:)
              goto 100
            endif
            lin = lin .or. (i .ge. iwk(1) .and. i .le. iwk(2) .and.
     .                      j .ge. iwk(3) .and. j .le. iwk(4))
          enddo

C         If (i,j) is outside all masks, zero it out
          if (.not. lin) then
            hrs(1,i,j,1,it1) = 0
            hrs(2,i,j,1,it1) = 0
            hrs(1,i,j,nsp,it1) = 0
            hrs(2,i,j,nsp,it1) = 0
          endif


        enddo
        enddo

        goto 100

C ... Mask hrs not in range
      elseif (outs(1:4) .eq. 'mask') then

        call words(outs,nw)
        if (nw .eq. 1) then
          print *, 'no ranges specified ... nothing to mask'
          goto 100
        endif

        do  it = it1, it2

C         See whether (i,j) is inside any mask
          lin = .false.
          do  i1 = 2, nw
            call word(outs,i1,j1,j2)
            l1 = j1-1
            j1 = a2vec(outs,len(outs),l1,2,', ',2,-3,2,ix,iwk)
            if (j1 .ne. 2) then
              print 306, outs(i1:)
              goto 100
            endif
            lin = lin .or. (it .ge. iwk(1) .and. it .le. iwk(2))
          enddo

C         If (it) is outside all masks, zero it out
          if (.not. lin) then
            call dpzero(hrs(1,1,1,1,it),2*ndhrs*ndhrs*nsp)
          endif

        enddo

        goto 100

C ... Show sigma for range of pairs
      elseif (outs(1:5) .eq. 'shows' .or. outs(1:6) .eq. 'showsd') then

        call words(outs,nw)

        do  i = 1, max(nw-1,1)
          if (nw .eq. 1) then
            call icopy(4,isub,1,iwk,1)
          else
            call word(outs,i+1,j1,j2)
            l1 = j1-1
            if (outs(1:6) .eq. 'showsd') then            
              j1 = a2vec(outs,len(outs),l1,2,', ',2,-3,2,ix,iwk)
              if (j1 .ne. 2) then
                print 306, outs(l1:)
                goto 100
              endif
            else
              j1 = a2vec(outs,len(outs),l1,2,', ',2,-3,4,ix,iwk)
              if (j1 .ne. 4) then
                print 306, outs(l1:)
                goto 100
              endif
            endif
          endif

          do  it = it1, it2
          ib = iax(1,it)
          jb = iax(2,it)
          rr = dsqrt(drr2(plat,pos(1,ib),pos(1,jb),
     .      iax(3,it),iax(4,it),iax(5,it),vlat))
          write(stdo,332)
          write(stdo,334) iax(1,it),iax(2,it),
     .      (vlat(j),j=1,3), rr, (iax(j,it), j=3,5), it

          do  isp = 1, nsp
            if (outs(1:6) .eq. 'showsd') then
              write(stdo,'(19f12.6)')
     .          (hrs(1,j1,j1,isp,it), j1=iwk(1),iwk(2))
              write(stdo,'(19f12.6)')
     .          (hrs(2,j1,j1,isp,it), j1=iwk(1),iwk(2))
            else
            call awrit5('rows (%i,%i) cols (%i,%i) spin %i',strn,80,0,
     .        iwk(1),iwk(2),iwk(3),iwk(4),isp)
            call ywrm(0,strn,3,stdo,'(19f12.6)',
     .        hrs(1,iwk(1),iwk(3),isp,it),1,ndhrs,
     .        iwk(2)-iwk(1)+1,iwk(4)-iwk(3)+1)
            endif
          enddo
          enddo
        enddo

        goto 100

      elseif (outs(1:5) .eq. 'showp' ) then

        i = 0
        do  it = it1, it2
          ib = iax(1,it)
          jb = iax(2,it)
          rr = dsqrt(drr2(plat,pos(1,ib),pos(1,jb),
     .      iax(3,it),iax(4,it),iax(5,it),vlat))
          if (ib .ne. i) then
            write(stdo,332)
  332       format(/'  ib  jb',9x,'--- r(jb)-r(ib) ---',10x,
     .        'd       -x-plat-   pair')
C            write(stdo,345) ib,ntab(ib+1)-ntab(ib),rcut
C  345       format(' pairc, ib=',i3,':',i4,' neighbors in range',f7.3)
          endif
          i = ib
          if (rr .lt. rcut) then
            write(stdo,334) iax(1,it),iax(2,it),
     .        (vlat(j),j=1,3), rr, (iax(j,it), j=3,5), it
  334       format(i4,i4,3f11.6,f9.4,3x,3i3,i6)
          endif
        enddo

        goto 100

C ... abort
      elseif (outs(1:1) .eq. 'a') then
        call rx0('aborting sigma editor ... no file written')

C ... quit
      elseif (outs(1:1) .eq. 'q') then
        goto 199

C ... help
      elseif (outs .eq. '?') then
        print 310
  310   format(/
     .  ' Editor works with a range of pairs,',
     .    ' or with a particular pair.'/
     .    ' In the latter case, you can edit a subblock',
     .    ' of h(rs) for that pair'//
     .    ' Select one of these options:'/
C    .  t4,'i',t10,'to import a portion of a sigma file'/
     .  t4,'pair',t10, '[#1 [#2]] specifies a pair or range of pairs',
     .    ' used by other options.'/
     .           ,t10, 'Use only #1 to select a specific pair.'/
     .           ,t10, 'Use no arguments to select all pairs.'/
     .  t4,'sum', t10, 'summarizes : pair table,',
     .    ' or sigma for given pair')
        print 311
  311   format(
     .  t4,'sub',  t10, '              work with entire block of hrs'/
     .  t4,'sub',  t10, 'r1,r2,c1,c2 : define subblock of hrs'/
     .             t10, 'other options use.'/
     .  t4,'mask', t10, 'range1 range2 ... zero hrs for pairs not in'/
     .             t10, 'one of supplied ranges'/
     .             t10, 'range* has structure #1,#2'/
     .             t10, 'Applies to range of pairs specified',
     .                  'with "pair"'/
     .  t4,'mask', t10, 'subbl1 subbl2 ... zero hrs(current pair) for '/
     .             t10, 'any element not in one of supplied subblocks'/
     .             t10, 'subbl* has structure r1,r2,c1,c2'/
     .             t10, 'Applies to one pair only'/
     .  t4,'showp',t10, 'shows pairs within table'/
     .  t4,'shows' t10, '[r1,r2,c1,c2] shows subblock of sigma, for '/
     .             t10, 'list of pairs specified by ''pair'' command'/
     .  t4,'edit', t10, '(does nothing), or matrix element of sigma'/
     .  t4,'q',t10,'to quit the editor'/
     .  t4,'a',t10,'to abort (no sigma file is written)'/
     .  )
        goto 100

      else
        print '(1x,''unrecognized option: '',a10)', outs
        goto 100

      endif

C ... Cleanup and exit rst editor
  199 continue
Cgetarg       end
       end subroutine siged 


      subroutine sigflg(dc,sio,strn,ledit,lwsig,lrot,lfbz,lnwmsh,lonesp,
     .  qpoff,rots)

C- Reads flags for Sigma IO
C ----------------------------------------------------------------------
Ci Inputs
Ci   dc:   separator for switches
Ci  sio:   a string, which must be one of :
Ci         'rsig' --- parse parameters for reading sigma:
Ci                lfbz qpoff
Ci         'wsig' --- parse parameters for writing a new sigma:
Ci                ledit lwsig lrot lfbz lnwmsh lonesp qpoff rots
Ci   strn: string containing switches
Co Outputs
Co   ledit :(wsig only)
Co         :1  flag requesting sigma editor
Co   lwsig :(wsig only)
Co         :0 normal exit
Co         :1  transformation of sigm from orbital to LDA basis
Co         :-1 transformation of from LDA basis to orbital basis
Co         :2  Same as 1, but high,low parts of sigm replaced by diagonal
Co         :3  Write evals,evecs of LDA hamiltonian to file
Co         :4  Write evals,evecs of total hamiltonian to file
Co         : OLD; not used
Co         :4  Make QP hamiltonian from Z^LDA and U with E(qp)
Co         :5  Make orthogonalized QP hamiltonian from Z^LDA and U with E(qp)
Co   lrot  :(wsig only)
Co         :nonzero, flag to rotate sigma matrix
Co   lfbz  :(rdsig and wsig)
Co         :T, write sigma for qp in entire BZ
Co   lnwmsh:(wsig only)
Co         :T, write sigm for qp on new mesh
Co   lonesp:(wsig only)
Co         :nonzero, average up and down spins before writing
Co   qpoff :(rdsig and wsig)
Co         :k-point offset to be added to uniform mesh
Co   rots  :(wsig only)
Co         :string containing rotation matrix for sigma
Cl Local variables
Cl         :
Cr Remarks
Cr
Cu Updates
Cu   21 Jun 08
Cu   15 Jan 07  First created
C ----------------------------------------------------------------------
C     implicit none
C ... Passed parameters
      character dc*1,sio*(4)
      character strn*(*),rots*(*)
      integer ledit,lwsig,lrot,lonesp
      logical lfbz,lnwmsh
      double precision qpoff(3)
C ... Local parameters
      integer parg
      integer i,j,j1,j2,iv(10)
      logical lio

      lio = sio .eq. 'wsig'
      if (.not. lio) then
        if (sio .ne. 'rsig') call rx('sigflg: bad argument '//sio)
      endif
      if (lio) then
        ledit = 0
        lwsig = 0
        lrot = 0
        lfbz = .false.
        lnwmsh = .false.
        lonesp = 0
        rots = ' '
        call dpzero(qpoff,3)
      else
        lfbz = .false.
        lonesp = 0
        call dpzero(qpoff,3)
      endif

      if (dc .ne. ' ') then
C   ... Return here to resume parsing for arguments
        j2 = 0
   50   continue
        j2 = j2+1
        if (strn(j2:j2) .eq. dc) goto 50
        j1 = min(len(strn),j2)
        call nwordg(strn,0,dc//' ',1,j1,j2)
        if (j2 .ge. j1) then
          if (.false.) then
          elseif (strn(j1:j1+3) .eq. 'edit'.and. lio) then
            ledit = 1
          elseif (strn(j1:j1+4) .eq. 'onesp') then
            lonesp = 1
          elseif ((strn(j1:j1+3) .eq. 'rot=' .or.
     .            strn(j1:j1+3) .eq. 'ROT=') .and. lio) then
            rots = strn(j1+4:j2)
          elseif (strn(j1:j1+5) .eq. 'trans=' .and. lio) then
            j = 0
            if (parg('trans=',2,strn(j1:),j,len(strn(j1:)),
     .        dc//' ',1,1,i,lwsig) .lt. 0) goto 999
            call isanrg(mod(lwsig,10),-1,5,'SIGFLG:','trans',.true.)
            if (lwsig .ne. 0 .and. mod(lwsig,10) .eq. 0 .or.
     .          lwsig .ge. 40)
     .        call rxi('rdsigm: nonsensical trans',lwsig)
          elseif (strn(j1:j1+4) .eq. 'phase'.and. lio) then
            lrot = 2
          elseif (strn(j1:j1+2) .eq. 'fbz') then
            lfbz = .true.
          elseif (strn(j1:j1+4) .eq. 'newkp'.and. lio) then
            lnwmsh = .true.
          elseif (strn(j1:j1+5) .eq. 'shftq=') then
            j = 0
            if (parg('shftq=',4,strn(j1:),j,len(strn(j1:)),
     .        ', '//dc,2,3,iv,qpoff) .lt. 0) goto 999
          elseif (strn(j1:j1+4) .eq. 'shftq') then
            qpoff(1) = 4d0/4096
            qpoff(2) = 5d0/4096
            qpoff(3) = 7d0/4096
          else
            goto 59
          endif
          goto 50
   59     continue
  999     call rxs('rdsigm: failed to parse wsig option', strn)
        endif
      endif

Cgetarg       end
       end subroutine sigflg 


C      subroutine sigfn(io,lwsig,ifi)
CC- Opens file and returns file logical unit for sigm transformation modes
CC ----------------------------------------------------------------------
CCi Inputs
CCi   io    :0 => open input file ifi
CCi         :1 => open output file ifi
CCi   lwsig
CCo Outputs
CCo   ifi   :file logical unit
CCl Local variables
CCl         :
CCr Remarks
CCr
CCu Updates
CCu   20 Dec 07
CC ----------------------------------------------------------------------
C      implicit none
C      integer io,lwsig,ifi
C      integer fopna
C
C      if (lwsig .eq. 1 .or. lwsig .eq. 2) then
C        if (io .eq. 0) ifi = fopna('sigm',-1,4)
C        if (io .eq. 1) ifi = fopna('sigm2',-1,4)
C      elseif (lwsig .eq. -1) then
C        if (io .eq. 0) ifi = fopna('sigm2',-1,4)
C        if (io .eq. 1) ifi = fopna('sigm3',-1,4)
C      elseif (lwsig .eq. 3) then
C        if (io .eq. 0) ifi = fopna('sigm3',-1,4)
C        if (io .eq. 1) ifi = fopna('sigm2',-1,4)
C      else
C        ifi = fopna('sigm',-1,4)
C      endif
C
C      end




C ... titus
C      subroutine getoffH(offHo,offH,n0H,nkap0,nbas)
C      implicit none
C      integer n0H,nkap0,nbas
C      integer offHo(n0H,nkap0,nbas+1),offH(n0H,nkap0,nbas+1)
C      integer i,j,k
C      do 11 k = 1, (nbas+1)
C      do 11 j = 1, nkap0
C      do 11 i = 1, n0H
C
C        offH(i,j,k)= offHo(i,j,k)
C 11   continue
C
C      end
C ... titus

C      subroutine pvtrod(sfz,k1,k2,k3,ldim)
C      integer k1,k2,k3,ldim
C      double complex sfz(k1,k2,k3,ldim,ldim)
C      integer i1,i2
C
C      i1 = 38
C      i2 = 38
C      call zprm3('gf(i1,i2)',0,sfz(1,1,1,i1,i2),k1,k2,k3)
C      return
C
C      call zprm3('gf(2,1)',0,sfz(1,1,1,2,1),k1,k2,k3)
C      call zprm3('gf(1,2)',0,sfz(1,1,1,1,2),k1,k2,k3)
C      end


ctakaox
      subroutine divctakao(a,b,n)

      integer:: n,i,j
      complex(8):: a(n,n),b(n,n)
      print *,' sum check 1=',sum(abs(a))
      print *,' sum check 1=',sum(abs(b))
      do i=1,n
      do j=1,n
c        write(6,"(2i5,2x, 4d13.4,3x,2d13.5)") 
c     &  i,j,atan(dimag(a(i,j)/dreal(a(i,j))))       if( abs(a(i,j))>1d-3 ) 
c     &   write(6,"(2i5,2x, 4d13.4,3x,2d13.5)")i,j,a(i,j)
c     &   ,atan(dimag(a(i,j)/dreal(a(i,j))))
c,b(i,j),
c     &  a(i,j)/( b(i,j)+b(i,j)*0.01/abs(b(i,j)) )
c        a(i,j) = a(i,j)/ ( b(i,j)+b(i,j)*0.01/abs(b(i,j)) )
c        a(i,j)=a(i,j)/b(i,j)
      enddo
      enddo
      print *,' sum check 2=',sum(abs(a))
Cgetarg       end
       end subroutine divctakao 

